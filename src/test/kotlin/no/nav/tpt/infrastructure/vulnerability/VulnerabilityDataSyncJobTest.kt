package no.nav.tpt.infrastructure.vulnerability

import io.ktor.client.HttpClient
import io.ktor.client.engine.mock.*
import kotlinx.coroutines.runBlocking
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.infrastructure.nais.*
import no.nav.tpt.plugins.LeaderElection
import java.time.Instant
import kotlin.test.*

class VulnerabilityDataSyncJobTest {

    @Test
    fun `should skip sync when not leader`() = runBlocking {
        val httpClient = createMockHttpClient()
        val naisApiService = MockNaisApiServiceForSync()
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = false
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertFalse(naisApiService.getAllTeamsCalled)
        assertEquals(0, repository.upsertCount)
    }

    @Test
    fun `should sync all teams when leader`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(
            TeamInfo("team-a", "#team-a"),
            TeamInfo("team-b", "#team-b")
        )
        val naisApiService = MockNaisApiServiceForSync(teams = teams)
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertTrue(naisApiService.getAllTeamsCalled)
        assertEquals(2, naisApiService.getVulnerabilitiesForTeamCallCount)
        assertEquals(4, repository.upsertCount)
        assertEquals(2, repository.deleteOldDataCount)
    }

    @Test
    fun `should handle NAIS API response with multiple workloads and vulnerabilities`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/my-org/my-app:v1.2.3",
                                repository = "https://github.com/my-org/my-app",
                                environment = "prod",
                                ingressTypes = listOf("external", "internal"),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-1234",
                                        severity = "CRITICAL",
                                        packageName = "log4j",
                                        description = "Critical vulnerability",
                                        vulnerabilityDetailsLink = "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-5678",
                                        severity = "HIGH",
                                        packageName = "spring-core",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val firstVuln = repository.upsertedVulnerabilities[0]
        assertEquals("test-team", firstVuln.teamSlug)
        assertEquals("#test", firstVuln.teamSlackChannel)
        assertEquals("app-1", firstVuln.appNaisId)
        assertEquals("my-app", firstVuln.appName)
        assertEquals("NAIS_APPLICATION", firstVuln.appWorkloadType)
        assertEquals("prod", firstVuln.appEnvironment)
        assertEquals("https://github.com/my-org/my-app", firstVuln.appRepository)
        assertEquals("ghcr.io/my-org/my-app", firstVuln.appImageName)
        assertEquals("ghcr.io/my-org/my-app:v1.2.3", firstVuln.appImageTag)
        assertTrue(firstVuln.appHasExternalIngress)
        assertEquals(listOf("external", "internal"), firstVuln.appIngressTypes)
        assertEquals("CVE-2024-1234", firstVuln.cveId)
        assertEquals("log4j", firstVuln.packageName)
        assertEquals("CRITICAL", firstVuln.severity)
        assertFalse(firstVuln.suppressed)
    }

    @Test
    fun `should extract image name correctly from image tag`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/navikt/my-app:2024.01.15-12.34.56-abcd123",
                                repository = null,
                                environment = "dev",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1", "LOW", null, null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        val vuln = repository.upsertedVulnerabilities[0]
        assertEquals("ghcr.io/navikt/my-app", vuln.appImageName)
        assertEquals("ghcr.io/navikt/my-app:2024.01.15-12.34.56-abcd123", vuln.appImageTag)
    }

    @Test
    fun `should handle empty vulnerabilities response`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("empty-team", "#empty"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(teams = emptyList())
        )
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(0, repository.upsertCount)
        assertEquals(1, repository.deleteOldDataCount)
    }

    @Test
    fun `should continue syncing other teams when one team fails`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(
            TeamInfo("good-team", "#good"),
            TeamInfo("bad-team", "#bad"),
            TeamInfo("another-good-team", "#good2")
        )
        val naisApiService = MockNaisApiServiceForSync(teams = teams, failOnTeam = "bad-team")
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(4, repository.upsertCount)
        assertEquals(3, repository.deleteOldDataCount)
    }

    @Test
    fun `should skip vulnerabilities with validation errors and continue processing`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/my-org/my-app:v1.0.0",
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-VALID-ID",
                                        severity = "HIGH",
                                        packageName = "valid-package",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-THIS-IS-WAY-TOO-LONG-ID-EXCEEDS-FIFTY-CHARS",
                                        severity = "HIGH",
                                        packageName = "invalid-package",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-ANOTHER",
                                        severity = "CRITICAL",
                                        packageName = "another-valid",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-VALID-ID"))
        assertTrue(insertedCves.contains("CVE-2024-ANOTHER"))
        assertFalse(insertedCves.contains("CVE-2024-THIS-IS-WAY-TOO-LONG-ID-EXCEEDS-FIFTY-CHARS"))
    }

    @Test
    fun `should skip vulnerabilities when database upsert fails and continue processing`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1", "HIGH", "pkg1", null, null, false),
                                    VulnerabilityData("CVE-FAIL", "HIGH", "pkg2", null, null, false),
                                    VulnerabilityData("CVE-2024-3", "CRITICAL", "pkg3", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestSyncJobRepository(failOnCveId = "CVE-FAIL")
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-1"))
        assertTrue(insertedCves.contains("CVE-2024-3"))
        assertFalse(insertedCves.contains("CVE-FAIL"))
    }

    @Test
    fun `should handle longer CVE identifiers like UBUNTU-CVE format`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1234", "HIGH", "pkg1", null, null, false),
                                    VulnerabilityData("UBUNTU-CVE-2024-12797", "MEDIUM", "pkg2", null, null, false),
                                    VulnerabilityData("GHSA-xxxx-yyyy-zzzz", "CRITICAL", "pkg3", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestSyncJobRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(3, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-1234"))
        assertTrue(insertedCves.contains("UBUNTU-CVE-2024-12797"))
        assertTrue(insertedCves.contains("GHSA-xxxx-yyyy-zzzz"))
    }

    @Test
    fun `should clean up vulnerabilities for removed applications`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("team-a", "#team-a"))
        
        val syncTime1 = Instant.now().minusSeconds(3600)
        val repository = TestSyncJobRepository()
        
        repository.upsertVulnerability(
            no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData(
                id = null,
                teamSlug = "team-a",
                teamSlackChannel = "#team-a",
                appNaisId = "old-app-id",
                appName = "old-app",
                appWorkloadType = "NAIS_APPLICATION",
                appEnvironment = "prod",
                appRepository = "navikt/old-app",
                appImageName = "old-app",
                appImageTag = "1.0.0",
                appHasExternalIngress = false,
                appIngressTypes = emptyList(),
                cveId = "CVE-2023-OLD",
                packageName = "old-pkg",
                severity = "HIGH",
                description = "Old vulnerability",
                vulnerabilityDetailsLink = null,
                suppressed = false,
                discoveredAt = syncTime1,
                lastSeenAt = syncTime1,
                resolvedAt = null,
                syncTimestamp = syncTime1
            )
        )
        
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "new-app-id",
                                name = "new-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "2.0.0",
                                repository = "navikt/new-app",
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-NEW", "CRITICAL", "new-pkg", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }
        
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount, "Should have 2 upserts: 1 old + 1 new")
        assertEquals(1, repository.deleteOldDataCount, "Should have called deleteOldDataForTeam once")
        
        val deletedBeforeTime = repository.lastDeleteBeforeTimestamp
        assertNotNull(deletedBeforeTime, "Should have captured delete timestamp")
        assertTrue(deletedBeforeTime.isAfter(syncTime1), "Delete timestamp should be after the old sync time")
        
        val remainingVulns = repository.upsertedVulnerabilities.filter { 
            it.syncTimestamp.isAfter(syncTime1) || it.syncTimestamp == syncTime1
        }
        assertEquals(1, remainingVulns.size, "Should only have the new vulnerability after cleanup simulation")
        assertEquals("CVE-2024-NEW", remainingVulns[0].cveId)
    }

    @Test
    fun `CVE cleanup should not delete CVEs used by other teams`() = runBlocking {
        val repository = MockVulnerabilityRepository()
        val sharedCveId = "CVE-2024-SHARED"
        val syncTime1 = Instant.now().minusSeconds(3600)
        val syncTime2 = Instant.now()
        
        repository.upsertVulnerability(
            no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData(
                id = null,
                teamSlug = "team-a",
                teamSlackChannel = null,
                appNaisId = "app-a-1",
                appName = "app-a",
                appWorkloadType = "NAIS_APPLICATION",
                appEnvironment = "prod",
                appRepository = null,
                appImageName = null,
                appImageTag = null,
                appHasExternalIngress = false,
                appIngressTypes = emptyList(),
                cveId = sharedCveId,
                packageName = "shared-pkg",
                severity = "HIGH",
                description = "Shared CVE",
                vulnerabilityDetailsLink = null,
                suppressed = false,
                discoveredAt = syncTime1,
                lastSeenAt = syncTime1,
                resolvedAt = null,
                syncTimestamp = syncTime1
            )
        )
        
        repository.upsertVulnerability(
            no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData(
                id = null,
                teamSlug = "team-b",
                teamSlackChannel = null,
                appNaisId = "app-b-1",
                appName = "app-b",
                appWorkloadType = "NAIS_APPLICATION",
                appEnvironment = "prod",
                appRepository = null,
                appImageName = null,
                appImageTag = null,
                appHasExternalIngress = false,
                appIngressTypes = emptyList(),
                cveId = sharedCveId,
                packageName = "shared-pkg",
                severity = "HIGH",
                description = "Shared CVE",
                vulnerabilityDetailsLink = null,
                suppressed = false,
                discoveredAt = syncTime2,
                lastSeenAt = syncTime2,
                resolvedAt = null,
                syncTimestamp = syncTime2
            )
        )
        
        val countBeforeCleanup = repository.getUpsertedVulnerabilities().size
        assertEquals(2, countBeforeCleanup, "Should have 2 vulnerabilities with same CVE before cleanup")
        
        val deletedCount = repository.deleteOldDataForTeam("team-a", syncTime2)
        
        assertEquals(1, deletedCount, "Should delete 1 vulnerability record from team-a")
        
        val remainingVulns = repository.getUpsertedVulnerabilities()
        assertEquals(1, remainingVulns.size, "Should have 1 vulnerability remaining")
        assertEquals("team-b", remainingVulns[0].teamSlug, "Team B's vulnerability should remain")
        assertEquals(sharedCveId, remainingVulns[0].cveId, "Shared CVE should still be referenced by team-b")
    }

    private fun createMockHttpClient(): HttpClient {
        return HttpClient(MockEngine) {
            engine {
                addHandler { _ ->
                    respondOk()
                }
            }
        }
    }
}

class MockNaisApiServiceForSync(
    private val teams: List<TeamInfo> = emptyList(),
    private val vulnerabilitiesData: UserVulnerabilitiesData = UserVulnerabilitiesData(
        teams = listOf(
            TeamVulnerabilitiesData(
                teamSlug = "default",
                workloads = listOf(
                    WorkloadData(
                        id = "app-1",
                        name = "app",
                        workloadType = "NAIS_APPLICATION",
                        imageTag = null,
                        repository = null,
                        environment = "dev",
                        ingressTypes = emptyList(),
                                createdAt = null,
                        vulnerabilities = listOf(
                            VulnerabilityData("CVE-2024-1", "MEDIUM", "pkg", null, null, false),
                            VulnerabilityData("CVE-2024-2", "HIGH", "pkg2", null, null, false)
                        )
                    )
                )
            )
        )
    ),
    private val failOnTeam: String? = null
) : NaisApiService {
    var getAllTeamsCalled = false
    var getVulnerabilitiesForTeamCallCount = 0

    override suspend fun getAllTeams(): List<TeamInfo> {
        getAllTeamsCalled = true
        return teams
    }

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        return vulnerabilitiesData
    }

    override suspend fun getVulnerabilitiesForTeam(teamSlug: String): UserVulnerabilitiesData {
        if (teamSlug == failOnTeam) {
            throw RuntimeException("Simulated failure for team $teamSlug")
        }
        getVulnerabilitiesForTeamCallCount++
        return vulnerabilitiesData
    }

    override suspend fun getTeamMembershipsForUser(email: String): List<String> {
        return emptyList()
    }
}

class TestSyncJobRepository(
    private val failOnCveId: String? = null
) : VulnerabilityRepository {
    var upsertCount = 0
    var deleteOldDataCount = 0
    var lastDeleteBeforeTimestamp: Instant? = null
    val upsertedVulnerabilities = mutableListOf<no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData>()
    private val teamSyncMetadata = mutableMapOf<String, Instant>()

    override suspend fun upsertVulnerability(vulnerability: no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData): no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData {
        if (vulnerability.cveId == failOnCveId) {
            throw RuntimeException("Simulated database error for CVE $failOnCveId")
        }
        upsertCount++
        upsertedVulnerabilities.add(vulnerability)
        return vulnerability
    }

    override suspend fun batchUpsertVulnerabilities(vulnerabilities: List<no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData>): Int {
        var count = 0
        for (vuln in vulnerabilities) {
            try {
                upsertVulnerability(vuln)
                count++
            } catch (e: Exception) {
                // skip failed items
            }
        }
        return count
    }

    override suspend fun getActiveVulnerabilitiesForTeams(
        teamSlugs: List<String>
    ): List<no.nav.tpt.domain.vulnerability.VulnerabilitySearchResult> {
        throw NotImplementedError()
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, currentSyncTime: Instant): Int {
        deleteOldDataCount++
        lastDeleteBeforeTimestamp = currentSyncTime
        val deletedCount = upsertedVulnerabilities.count { it.syncTimestamp.isBefore(currentSyncTime) }
        upsertedVulnerabilities.removeIf { it.syncTimestamp.isBefore(currentSyncTime) }
        return deletedCount
    }

    override suspend fun getTeamVulnerabilityCounts(): List<no.nav.tpt.domain.vulnerability.TeamVulnerabilityCount> {
        return emptyList()
    }

    override suspend fun getTeamSlaSummaries(): List<no.nav.tpt.domain.vulnerability.TeamSlaSummary> {
        return emptyList()
    }

    override suspend fun getTeamSlaDetails(teamSlugs: List<String>): List<no.nav.tpt.domain.vulnerability.TeamSlaDetails> {
        return emptyList()
    }
    
    override suspend fun updateTeamSyncMetadata(teamSlug: String, syncTime: Instant) {
        teamSyncMetadata[teamSlug] = syncTime
    }
    
    override suspend fun getTeamLastSyncTime(teamSlug: String): Instant? {
        return teamSyncMetadata[teamSlug]
    }
    
    override suspend fun getTeamsNeedingSync(teamSlugs: List<String>, olderThan: Instant): List<String> {
        return teamSlugs.filter { teamSlug ->
            val lastSync = teamSyncMetadata[teamSlug]
            lastSync == null || lastSync.isBefore(olderThan)
        }
    }
}
