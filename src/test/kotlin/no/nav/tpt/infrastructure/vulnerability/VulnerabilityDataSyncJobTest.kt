package no.nav.tpt.infrastructure.vulnerability

import io.ktor.client.HttpClient
import io.ktor.client.engine.mock.*
import kotlinx.coroutines.runBlocking
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.infrastructure.nais.*
import no.nav.tpt.plugins.LeaderElection
import java.time.Instant
import kotlin.test.*

class VulnerabilityDataSyncJobTest {

    @Test
    fun `should skip sync when not leader`() = runBlocking {
        val httpClient = createMockHttpClient()
        val naisApiService = MockNaisApiServiceForSync()
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = false
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertFalse(naisApiService.getAllTeamsCalled)
        assertEquals(0, repository.upsertCount)
    }

    @Test
    fun `should sync all teams when leader`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(
            TeamInfo("team-a", "#team-a"),
            TeamInfo("team-b", "#team-b")
        )
        val naisApiService = MockNaisApiServiceForSync(teams = teams)
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertTrue(naisApiService.getAllTeamsCalled)
        assertEquals(2, naisApiService.getVulnerabilitiesForTeamCallCount)
        assertEquals(4, repository.upsertCount)
        assertEquals(2, repository.deleteOldDataCount)
    }

    @Test
    fun `should handle NAIS API response with multiple workloads and vulnerabilities`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/my-org/my-app:v1.2.3",
                                repository = "https://github.com/my-org/my-app",
                                environment = "prod",
                                ingressTypes = listOf("external", "internal"),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-1234",
                                        severity = "CRITICAL",
                                        packageName = "log4j",
                                        description = "Critical vulnerability",
                                        vulnerabilityDetailsLink = "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-5678",
                                        severity = "HIGH",
                                        packageName = "spring-core",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val firstVuln = repository.upsertedVulnerabilities[0]
        assertEquals("test-team", firstVuln.teamSlug)
        assertEquals("#test", firstVuln.teamSlackChannel)
        assertEquals("app-1", firstVuln.appNaisId)
        assertEquals("my-app", firstVuln.appName)
        assertEquals("NAIS_APPLICATION", firstVuln.appWorkloadType)
        assertEquals("prod", firstVuln.appEnvironment)
        assertEquals("https://github.com/my-org/my-app", firstVuln.appRepository)
        assertEquals("ghcr.io/my-org/my-app", firstVuln.appImageName)
        assertEquals("ghcr.io/my-org/my-app:v1.2.3", firstVuln.appImageTag)
        assertTrue(firstVuln.appHasExternalIngress)
        assertEquals(listOf("external", "internal"), firstVuln.appIngressTypes)
        assertEquals("CVE-2024-1234", firstVuln.cveId)
        assertEquals("log4j", firstVuln.packageName)
        assertEquals("CRITICAL", firstVuln.severity)
        assertFalse(firstVuln.suppressed)
    }

    @Test
    fun `should extract image name correctly from image tag`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/navikt/my-app:2024.01.15-12.34.56-abcd123",
                                repository = null,
                                environment = "dev",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1", "LOW", null, null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        val vuln = repository.upsertedVulnerabilities[0]
        assertEquals("ghcr.io/navikt/my-app", vuln.appImageName)
        assertEquals("ghcr.io/navikt/my-app:2024.01.15-12.34.56-abcd123", vuln.appImageTag)
    }

    @Test
    fun `should handle empty vulnerabilities response`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("empty-team", "#empty"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(teams = emptyList())
        )
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(0, repository.upsertCount)
        assertEquals(1, repository.deleteOldDataCount)
    }

    @Test
    fun `should continue syncing other teams when one team fails`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(
            TeamInfo("good-team", "#good"),
            TeamInfo("bad-team", "#bad"),
            TeamInfo("another-good-team", "#good2")
        )
        val naisApiService = MockNaisApiServiceForSync(teams = teams, failOnTeam = "bad-team")
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(4, repository.upsertCount)
        assertEquals(3, repository.deleteOldDataCount)
    }

    @Test
    fun `should skip vulnerabilities with validation errors and continue processing`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/my-org/my-app:v1.0.0",
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-VALID-ID",
                                        severity = "HIGH",
                                        packageName = "valid-package",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-THIS-IS-WAY-TOO-LONG-ID-EXCEEDS-FIFTY-CHARS",
                                        severity = "HIGH",
                                        packageName = "invalid-package",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    ),
                                    VulnerabilityData(
                                        identifier = "CVE-2024-ANOTHER",
                                        severity = "CRITICAL",
                                        packageName = "another-valid",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-VALID-ID"))
        assertTrue(insertedCves.contains("CVE-2024-ANOTHER"))
        assertFalse(insertedCves.contains("CVE-2024-THIS-IS-WAY-TOO-LONG-ID-EXCEEDS-FIFTY-CHARS"))
    }

    @Test
    fun `should skip vulnerabilities when database upsert fails and continue processing`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1", "HIGH", "pkg1", null, null, false),
                                    VulnerabilityData("CVE-FAIL", "HIGH", "pkg2", null, null, false),
                                    VulnerabilityData("CVE-2024-3", "CRITICAL", "pkg3", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestVulnerabilityRepository(failOnCveId = "CVE-FAIL")
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(2, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-1"))
        assertTrue(insertedCves.contains("CVE-2024-3"))
        assertFalse(insertedCves.contains("CVE-FAIL"))
    }

    @Test
    fun `should handle longer CVE identifiers like UBUNTU-CVE format`() = runBlocking {
        val httpClient = createMockHttpClient()
        val teams = listOf(TeamInfo("test-team", "#test"))
        val naisApiService = MockNaisApiServiceForSync(
            teams = teams,
            vulnerabilitiesData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "test-team",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "my-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-1234", "HIGH", "pkg1", null, null, false),
                                    VulnerabilityData("UBUNTU-CVE-2024-12797", "MEDIUM", "pkg2", null, null, false),
                                    VulnerabilityData("GHSA-xxxx-yyyy-zzzz", "CRITICAL", "pkg3", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        val repository = TestVulnerabilityRepository()
        val leaderElection = object : LeaderElection(httpClient) {
            override fun isLeader() = true
        }

        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val syncJob = VulnerabilityDataSyncJob(
            naisApiService = naisApiService,
            vulnerabilityTeamSyncService = vulnerabilityTeamSyncService,
            vulnerabilityRepository = repository,
            leaderElection = leaderElection,
            teamDelayMs = 0
        )

        syncJob.syncAllTeams()

        assertEquals(3, repository.upsertCount)
        val insertedCves = repository.upsertedVulnerabilities.map { it.cveId }
        assertTrue(insertedCves.contains("CVE-2024-1234"))
        assertTrue(insertedCves.contains("UBUNTU-CVE-2024-12797"))
        assertTrue(insertedCves.contains("GHSA-xxxx-yyyy-zzzz"))
    }

    private fun createMockHttpClient(): HttpClient {
        return HttpClient(MockEngine) {
            engine {
                addHandler { _ ->
                    respondOk()
                }
            }
        }
    }
}

class MockNaisApiServiceForSync(
    private val teams: List<TeamInfo> = emptyList(),
    private val vulnerabilitiesData: UserVulnerabilitiesData = UserVulnerabilitiesData(
        teams = listOf(
            TeamVulnerabilitiesData(
                teamSlug = "default",
                workloads = listOf(
                    WorkloadData(
                        id = "app-1",
                        name = "app",
                        workloadType = "NAIS_APPLICATION",
                        imageTag = null,
                        repository = null,
                        environment = "dev",
                        ingressTypes = emptyList(),
                                createdAt = null,
                        vulnerabilities = listOf(
                            VulnerabilityData("CVE-2024-1", "MEDIUM", "pkg", null, null, false),
                            VulnerabilityData("CVE-2024-2", "HIGH", "pkg2", null, null, false)
                        )
                    )
                )
            )
        )
    ),
    private val failOnTeam: String? = null
) : NaisApiService {
    var getAllTeamsCalled = false
    var getVulnerabilitiesForTeamCallCount = 0

    override suspend fun getAllTeams(): List<TeamInfo> {
        getAllTeamsCalled = true
        return teams
    }

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        return vulnerabilitiesData
    }

    override suspend fun getVulnerabilitiesForTeam(teamSlug: String): UserVulnerabilitiesData {
        if (teamSlug == failOnTeam) {
            throw RuntimeException("Simulated failure for team $teamSlug")
        }
        getVulnerabilitiesForTeamCallCount++
        return vulnerabilitiesData
    }

    override suspend fun getTeamMembershipsForUser(email: String): List<String> {
        return emptyList()
    }
}

class TestVulnerabilityRepository(
    private val failOnCveId: String? = null
) : VulnerabilityRepository {
    var upsertCount = 0
    var deleteOldDataCount = 0
    val upsertedVulnerabilities = mutableListOf<no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData>()

    override suspend fun upsertVulnerability(vulnerability: no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData): no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData {
        if (vulnerability.cveId == failOnCveId) {
            throw RuntimeException("Simulated database error for CVE $failOnCveId")
        }
        upsertCount++
        upsertedVulnerabilities.add(vulnerability)
        return vulnerability
    }

    override suspend fun getActiveVulnerabilitiesForTeams(
        teamSlugs: List<String>
    ): List<no.nav.tpt.domain.vulnerability.VulnerabilitySearchResult> {
        throw NotImplementedError()
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, currentSyncTime: Instant): Int {
        deleteOldDataCount++
        return 0
    }

    override suspend fun getTeamVulnerabilityCounts(): List<no.nav.tpt.domain.vulnerability.TeamVulnerabilityCount> {
        return emptyList()
    }

    override suspend fun getTeamSlaSummaries(): List<no.nav.tpt.domain.vulnerability.TeamSlaSummary> {
        return emptyList()
    }

    override suspend fun getTeamSlaDetails(teamSlugs: List<String>): List<no.nav.tpt.domain.vulnerability.TeamSlaDetails> {
        return emptyList()
    }
}
