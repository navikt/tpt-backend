package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.runBlocking
import no.nav.tpt.domain.user.UserContext
import no.nav.tpt.domain.user.UserContextService
import no.nav.tpt.domain.vulnerability.VulnerabilitySearchResult
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.*
import java.time.Instant
import kotlin.test.*

class DatabaseVulnerabilityServiceTest {

    @Test
    fun `should return empty data when user has no teams`() = runBlocking {
        val userContextService = MockUserContextService(teams = emptyList())
        val repository = MockVulnerabilityRepository()
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(result.teams.isEmpty())
        assertFalse(repository.getActiveVulnerabilitiesCalled)
        assertFalse(naisApiService.getVulnerabilitiesForUserCalled)
    }

    @Test
    fun `should fetch and group vulnerabilities by team`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a", "team-b"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "CRITICAL"),
                createVulnResult("CVE-2024-2", "team-a", "app-1", "app-1-id", "HIGH"),
                createVulnResult("CVE-2024-3", "team-b", "app-2", "app-2-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertFalse(naisApiService.getVulnerabilitiesForUserCalled)
        assertEquals(listOf("team-a", "team-b"), repository.lastTeamSlugs)
        assertEquals(2, result.teams.size)

        val teamA = result.teams.find { it.teamSlug == "team-a" }
        assertNotNull(teamA)
        assertEquals(1, teamA.workloads.size)
        assertEquals(2, teamA.workloads[0].vulnerabilities.size)

        val teamB = result.teams.find { it.teamSlug == "team-b" }
        assertNotNull(teamB)
        assertEquals(1, teamB.workloads.size)
        assertEquals(1, teamB.workloads[0].vulnerabilities.size)
    }

    @Test
    fun `should group vulnerabilities by workload within teams`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "CRITICAL"),
                createVulnResult("CVE-2024-2", "team-a", "app-2", "app-2-id", "HIGH"),
                createVulnResult("CVE-2024-3", "team-a", "app-1", "app-1-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val teamA = result.teams[0]
        assertEquals(2, teamA.workloads.size)
        
        val app1 = teamA.workloads.find { it.name == "app-1" }
        assertNotNull(app1)
        assertEquals("app-1-id", app1.id)
        assertEquals(2, app1.vulnerabilities.size)

        val app2 = teamA.workloads.find { it.name == "app-2" }
        assertNotNull(app2)
        assertEquals("app-2-id", app2.id)
        assertEquals(1, app2.vulnerabilities.size)
    }

    @Test
    fun `should map vulnerability fields correctly`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                VulnerabilitySearchResult(
                    cveId = "CVE-2024-1234",
                    teamSlug = "team-a",
                    applicationName = "my-app",
                    applicationNaisId = "my-app-123",
                    workloadType = "NAIS_APPLICATION",
                    environment = "prod",
                    packageName = "log4j",
                    severity = "CRITICAL",
                    description = "Test vulnerability description",
                    vulnerabilityDetailsLink = "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
                    repository = "https://github.com/navikt/my-app",
                    imageTag = "ghcr.io/navikt/my-app:v1.0.0",
                    ingressTypes = listOf("external"),
                    hasExternalIngress = true,
                    suppressed = true,
                    discoveredAt = Instant.now(),
                    lastSeenAt = Instant.now()
                )
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val workload = result.teams[0].workloads[0]
        assertEquals("my-app-123", workload.id)
        assertEquals("my-app", workload.name)
        assertEquals("NAIS_APPLICATION", workload.workloadType)
        assertEquals("prod", workload.environment)
        assertEquals("https://github.com/navikt/my-app", workload.repository)
        assertEquals("ghcr.io/navikt/my-app:v1.0.0", workload.imageTag)
        assertEquals(listOf("external"), workload.ingressTypes)

        val vuln = workload.vulnerabilities[0]
        assertEquals("CVE-2024-1234", vuln.identifier)
        assertEquals("CRITICAL", vuln.severity)
        assertEquals("log4j", vuln.packageName)
        assertEquals("Test vulnerability description", vuln.description)
        assertEquals("https://nvd.nist.gov/vuln/detail/CVE-2024-1234", vuln.vulnerabilityDetailsLink)
        assertTrue(vuln.suppressed)
    }

    @Test
    fun `should filter out teams with no workloads`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a", "team-b", "team-c"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "HIGH"),
                createVulnResult("CVE-2024-2", "team-c", "app-2", "app-2-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertEquals(2, result.teams.size)
        assertNull(result.teams.find { it.teamSlug == "team-b" })
    }

    @Test
    fun `should handle null severity gracefully`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", null)
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val vuln = result.teams[0].workloads[0].vulnerabilities[0]
        assertEquals("UNKNOWN", vuln.severity)
    }

    @Test
    fun `should sync missing teams when database is empty`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository(vulnerabilities = emptyList())
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-SYNC",
                                        severity = "HIGH",
                                        packageName = "test",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertEquals(1, result.teams.size)
        assertEquals("team-a", result.teams[0].teamSlug)
    }

    @Test
    fun `should fallback to NAIS API when database query fails`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository(throwException = true)
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-DB-FAILURE",
                                        severity = "HIGH",
                                        packageName = "test",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertTrue(naisApiService.getVulnerabilitiesForUserCalled)
        assertEquals(1, result.teams.size)
        assertEquals("CVE-2024-DB-FAILURE", result.teams[0].workloads[0].vulnerabilities[0].identifier)
    }

    @Test
    fun `should not sync team if recently synced within TTL window`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-no-vulns"))
        val repository = MockVulnerabilityRepository(vulnerabilities = emptyList())
        
        val recentSyncTime = Instant.now().minusSeconds(5 * 60)
        repository.updateTeamSyncMetadata("team-no-vulns", recentSyncTime)
        
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertFalse(naisApiService.getVulnerabilitiesForUserCalled, "Should not call NAIS API when team was recently synced")
        assertEquals(0, result.teams.size)
    }

    @Test
    fun `should sync team if last sync older than TTL window`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-stale"))
        val repository = MockVulnerabilityRepository(vulnerabilities = emptyList())
        
        val staleSyncTime = Instant.now().minusSeconds(35 * 60)
        repository.updateTeamSyncMetadata("team-stale", staleSyncTime)
        
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-stale",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-NEW",
                                        severity = "HIGH",
                                        packageName = "test",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        val updatedSyncTime = repository.getTeamLastSyncTime("team-stale")
        assertNotNull(updatedSyncTime, "Team sync metadata should be updated")
        assertTrue(updatedSyncTime.isAfter(staleSyncTime), "Sync time should be updated to current time")
    }

    @Test
    fun `should sync team with no vulnerabilities and track metadata`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-empty"))
        val repository = MockVulnerabilityRepository(vulnerabilities = emptyList())
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(teams = emptyList())
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        val syncTime = repository.getTeamLastSyncTime("team-empty")
        assertNotNull(syncTime, "Team with no vulnerabilities should still have sync metadata")
        assertEquals(0, result.teams.size)
    }

    @Test
    fun `should handle multiple teams with mixed sync states`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-recent", "team-stale", "team-never"))
        val repository = MockVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-recent", "app-1", "app-1-id", "HIGH")
            )
        )
        
        repository.updateTeamSyncMetadata("team-recent", Instant.now().minusSeconds(5 * 60))
        repository.updateTeamSyncMetadata("team-stale", Instant.now().minusSeconds(35 * 60))
        
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(teamSlug = "team-stale", workloads = emptyList()),
                    TeamVulnerabilitiesData(teamSlug = "team-never", workloads = emptyList())
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertNotNull(repository.getTeamLastSyncTime("team-recent"))
        assertNotNull(repository.getTeamLastSyncTime("team-stale"))
        assertNotNull(repository.getTeamLastSyncTime("team-never"), "Never-synced team should now have metadata")
        Unit
    }

    @Test
    fun `sync service should record metadata after syncing team with no vulnerabilities`() = runBlocking {
        val mockRepository = MockVulnerabilityRepository()
        val mockNaisApi = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(teams = emptyList())
        )
        val syncService = VulnerabilityTeamSyncService(mockNaisApi, mockRepository)

        val results = syncService.syncTeams(listOf("team-empty"))

        assertEquals(1, results.size)
        val result = results[0]
        assertEquals("team-empty", result.teamSlug)
        assertEquals(0, result.processed)
        assertEquals(0, result.inserted)
        
        val syncTime = mockRepository.getTeamLastSyncTime("team-empty")
        assertNotNull(syncTime, "Sync metadata should be recorded even when no vulnerabilities found")
        Unit
    }

    @Test
    fun `sync service should record metadata after syncing team with vulnerabilities`() = runBlocking {
        val mockRepository = MockVulnerabilityRepository()
        val mockNaisApi = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "ghcr.io/navikt/app:1.0.0",
                                repository = "navikt/app",
                                environment = "prod",
                                ingressTypes = listOf("external"),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-1234",
                                        severity = "HIGH",
                                        packageName = "test-pkg",
                                        description = "Test vulnerability",
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val syncService = VulnerabilityTeamSyncService(mockNaisApi, mockRepository)

        val results = syncService.syncTeams(listOf("team-a"))

        assertEquals(1, results.size)
        val result = results[0]
        assertEquals("team-a", result.teamSlug)
        assertEquals(1, result.processed)
        assertEquals(1, result.inserted)
        
        val syncTime = mockRepository.getTeamLastSyncTime("team-a")
        assertNotNull(syncTime, "Sync metadata should be recorded after successful sync")
        Unit
    }

    @Test
    fun `should clean up stale workloads on on-demand sync after TTL`() = runBlocking {
        val oldSyncTime = Instant.now().minusSeconds(3600)
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockVulnerabilityRepository()
        
        repository.upsertVulnerability(
            VulnerabilityTrackingData(
                id = null,
                teamSlug = "team-a",
                teamSlackChannel = null,
                appNaisId = "old-app-id",
                appName = "old-app",
                appWorkloadType = "NAIS_APPLICATION",
                appEnvironment = "prod",
                appRepository = null,
                appImageName = null,
                appImageTag = null,
                appHasExternalIngress = false,
                appIngressTypes = emptyList(),
                cveId = "CVE-2023-STALE",
                packageName = "old-pkg",
                severity = "HIGH",
                description = "Stale vulnerability",
                vulnerabilityDetailsLink = null,
                suppressed = false,
                discoveredAt = oldSyncTime,
                lastSeenAt = oldSyncTime,
                resolvedAt = null,
                syncTimestamp = oldSyncTime
            )
        )
        
        repository.updateTeamSyncMetadata("team-a", oldSyncTime)
        
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "new-app-id",
                                name = "new-app",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = "2.0.0",
                                repository = "navikt/new-app",
                                environment = "prod",
                                ingressTypes = emptyList(),
                                createdAt = null,
                                vulnerabilities = listOf(
                                    VulnerabilityData("CVE-2024-CURRENT", "CRITICAL", "new-pkg", null, null, false)
                                )
                            )
                        )
                    )
                )
            )
        )
        
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)
        
        service.getVulnerabilitiesForUser("user@example.com")
        
        assertEquals(1, repository.deleteOldDataCount, "Should clean up stale data on on-demand sync after TTL")
        
        val allVulns = repository.getActiveVulnerabilitiesForTeams(listOf("team-a"))
        assertTrue(allVulns.any { it.cveId == "CVE-2024-CURRENT" }, "New CVE should exist")
        assertFalse(allVulns.any { it.cveId == "CVE-2023-STALE" }, "Stale CVE should be removed")
    }

    private fun createVulnResult(
        cveId: String,
        teamSlug: String,
        appName: String,
        appId: String,
        severity: String?
    ): VulnerabilitySearchResult {
        return VulnerabilitySearchResult(
            cveId = cveId,
            teamSlug = teamSlug,
            applicationName = appName,
            applicationNaisId = appId,
            workloadType = "NAIS_APPLICATION",
            environment = "prod",
            repository = null,
            imageTag = null,
            ingressTypes = emptyList(),
            packageName = "test-pkg",
            severity = severity,
            description = null,
            vulnerabilityDetailsLink = null,
            hasExternalIngress = false,
            suppressed = false,
            discoveredAt = Instant.now(),
            lastSeenAt = Instant.now()
        )
    }
}

class MockUserContextService(
    private val teams: List<String>
) : UserContextService {
    override suspend fun getUserContext(email: String, groups: List<String>): UserContext {
        return UserContext(
            email = email,
            role = no.nav.tpt.domain.user.UserRole.DEVELOPER,
            teams = teams
        )
    }
}

class MockNaisApiService(
    private val fallbackData: UserVulnerabilitiesData = UserVulnerabilitiesData(teams = emptyList())
) : NaisApiService {
    var getVulnerabilitiesForUserCalled = false

    override suspend fun getAllTeams(): List<TeamInfo> {
        throw NotImplementedError()
    }

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        getVulnerabilitiesForUserCalled = true
        return fallbackData
    }

    override suspend fun getVulnerabilitiesForTeam(teamSlug: String): UserVulnerabilitiesData {
        return fallbackData
    }

    override suspend fun getTeamMembershipsForUser(email: String): List<String> {
        throw NotImplementedError()
    }
}
