package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.runBlocking
import no.nav.tpt.domain.user.UserContext
import no.nav.tpt.domain.user.UserContextService
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilitySearchResult
import no.nav.tpt.infrastructure.nais.*
import java.time.Instant
import kotlin.test.*

class DatabaseVulnerabilityServiceTest {

    @Test
    fun `should return empty data when user has no teams`() = runBlocking {
        val userContextService = MockUserContextService(teams = emptyList())
        val repository = MockDatabaseVulnerabilityRepository()
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(result.teams.isEmpty())
        assertFalse(repository.getActiveVulnerabilitiesCalled)
        assertFalse(naisApiService.getVulnerabilitiesForUserCalled)
    }

    @Test
    fun `should fetch and group vulnerabilities by team`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a", "team-b"))
        val repository = MockDatabaseVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "CRITICAL"),
                createVulnResult("CVE-2024-2", "team-a", "app-1", "app-1-id", "HIGH"),
                createVulnResult("CVE-2024-3", "team-b", "app-2", "app-2-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertFalse(naisApiService.getVulnerabilitiesForUserCalled)
        assertEquals(listOf("team-a", "team-b"), repository.lastTeamSlugs)
        assertEquals(2, result.teams.size)

        val teamA = result.teams.find { it.teamSlug == "team-a" }
        assertNotNull(teamA)
        assertEquals(1, teamA.workloads.size)
        assertEquals(2, teamA.workloads[0].vulnerabilities.size)

        val teamB = result.teams.find { it.teamSlug == "team-b" }
        assertNotNull(teamB)
        assertEquals(1, teamB.workloads.size)
        assertEquals(1, teamB.workloads[0].vulnerabilities.size)
    }

    @Test
    fun `should group vulnerabilities by workload within teams`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockDatabaseVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "CRITICAL"),
                createVulnResult("CVE-2024-2", "team-a", "app-2", "app-2-id", "HIGH"),
                createVulnResult("CVE-2024-3", "team-a", "app-1", "app-1-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val teamA = result.teams[0]
        assertEquals(2, teamA.workloads.size)
        
        val app1 = teamA.workloads.find { it.name == "app-1" }
        assertNotNull(app1)
        assertEquals("app-1-id", app1.id)
        assertEquals(2, app1.vulnerabilities.size)

        val app2 = teamA.workloads.find { it.name == "app-2" }
        assertNotNull(app2)
        assertEquals("app-2-id", app2.id)
        assertEquals(1, app2.vulnerabilities.size)
    }

    @Test
    fun `should map vulnerability fields correctly`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockDatabaseVulnerabilityRepository(
            vulnerabilities = listOf(
                VulnerabilitySearchResult(
                    cveId = "CVE-2024-1234",
                    teamSlug = "team-a",
                    applicationName = "my-app",
                    applicationNaisId = "my-app-123",
                    workloadType = "NAIS_APPLICATION",
                    environment = "prod",
                    packageName = "log4j",
                    severity = "CRITICAL",
                    description = "Test vulnerability description",
                    vulnerabilityDetailsLink = "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
                    repository = "https://github.com/navikt/my-app",
                    imageTag = "ghcr.io/navikt/my-app:v1.0.0",
                    ingressTypes = listOf("external"),
                    hasExternalIngress = true,
                    suppressed = true,
                    discoveredAt = Instant.now(),
                    lastSeenAt = Instant.now()
                )
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val workload = result.teams[0].workloads[0]
        assertEquals("my-app-123", workload.id)
        assertEquals("my-app", workload.name)
        assertEquals("NAIS_APPLICATION", workload.workloadType)
        assertEquals("prod", workload.environment)
        assertEquals("https://github.com/navikt/my-app", workload.repository)
        assertEquals("ghcr.io/navikt/my-app:v1.0.0", workload.imageTag)
        assertEquals(listOf("external"), workload.ingressTypes)

        val vuln = workload.vulnerabilities[0]
        assertEquals("CVE-2024-1234", vuln.identifier)
        assertEquals("CRITICAL", vuln.severity)
        assertEquals("log4j", vuln.packageName)
        assertEquals("Test vulnerability description", vuln.description)
        assertEquals("https://nvd.nist.gov/vuln/detail/CVE-2024-1234", vuln.vulnerabilityDetailsLink)
        assertTrue(vuln.suppressed)
    }

    @Test
    fun `should filter out teams with no workloads`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a", "team-b", "team-c"))
        val repository = MockDatabaseVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", "HIGH"),
                createVulnResult("CVE-2024-2", "team-c", "app-2", "app-2-id", "MEDIUM")
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertEquals(2, result.teams.size)
        assertNull(result.teams.find { it.teamSlug == "team-b" })
    }

    @Test
    fun `should handle null severity gracefully`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockDatabaseVulnerabilityRepository(
            vulnerabilities = listOf(
                createVulnResult("CVE-2024-1", "team-a", "app-1", "app-1-id", null)
            )
        )
        val naisApiService = MockNaisApiService()
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        val vuln = result.teams[0].workloads[0].vulnerabilities[0]
        assertEquals("UNKNOWN", vuln.severity)
    }

    @Test
    fun `should sync missing teams when database is empty`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockDatabaseVulnerabilityRepository(vulnerabilities = emptyList())
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-SYNC",
                                        severity = "HIGH",
                                        packageName = "test",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertEquals(1, result.teams.size)
        assertEquals("team-a", result.teams[0].teamSlug)
    }

    @Test
    fun `should fallback to NAIS API when database query fails`() = runBlocking {
        val userContextService = MockUserContextService(teams = listOf("team-a"))
        val repository = MockDatabaseVulnerabilityRepository(throwException = true)
        val naisApiService = MockNaisApiService(
            fallbackData = UserVulnerabilitiesData(
                teams = listOf(
                    TeamVulnerabilitiesData(
                        teamSlug = "team-a",
                        workloads = listOf(
                            WorkloadData(
                                id = "app-1",
                                name = "app-1",
                                workloadType = "NAIS_APPLICATION",
                                imageTag = null,
                                repository = null,
                                environment = "prod",
                                ingressTypes = emptyList(),
                                vulnerabilities = listOf(
                                    VulnerabilityData(
                                        identifier = "CVE-2024-DB-FAILURE",
                                        severity = "HIGH",
                                        packageName = "test",
                                        description = null,
                                        vulnerabilityDetailsLink = null,
                                        suppressed = false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        val vulnerabilityTeamSyncService = VulnerabilityTeamSyncService(naisApiService, repository)
        val service = DatabaseVulnerabilityService(repository, userContextService, naisApiService, vulnerabilityTeamSyncService)

        val result = service.getVulnerabilitiesForUser("user@example.com")

        assertTrue(repository.getActiveVulnerabilitiesCalled)
        assertTrue(naisApiService.getVulnerabilitiesForUserCalled)
        assertEquals(1, result.teams.size)
        assertEquals("CVE-2024-DB-FAILURE", result.teams[0].workloads[0].vulnerabilities[0].identifier)
    }

    private fun createVulnResult(
        cveId: String,
        teamSlug: String,
        appName: String,
        appId: String,
        severity: String?
    ): VulnerabilitySearchResult {
        return VulnerabilitySearchResult(
            cveId = cveId,
            teamSlug = teamSlug,
            applicationName = appName,
            applicationNaisId = appId,
            workloadType = "NAIS_APPLICATION",
            environment = "prod",
            repository = null,
            imageTag = null,
            ingressTypes = emptyList(),
            packageName = "test-pkg",
            severity = severity,
            description = null,
            vulnerabilityDetailsLink = null,
            hasExternalIngress = false,
            suppressed = false,
            discoveredAt = Instant.now(),
            lastSeenAt = Instant.now()
        )
    }
}

class MockUserContextService(
    private val teams: List<String>
) : UserContextService {
    override suspend fun getUserContext(email: String, groups: List<String>): UserContext {
        return UserContext(
            email = email,
            role = no.nav.tpt.domain.user.UserRole.DEVELOPER,
            teams = teams
        )
    }
}

class MockDatabaseVulnerabilityRepository(
    private val vulnerabilities: List<VulnerabilitySearchResult> = emptyList(),
    private val throwException: Boolean = false
) : VulnerabilityRepository {
    var getActiveVulnerabilitiesCalled = false
    var lastTeamSlugs: List<String>? = null
    private var callCount = 0
    private val syncedData = mutableListOf<VulnerabilitySearchResult>()

    override suspend fun upsertVulnerability(data: no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData): no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData {
        // Simulate storing the data
        syncedData.add(VulnerabilitySearchResult(
            cveId = data.cveId,
            teamSlug = data.teamSlug,
            applicationName = data.appName,
            applicationNaisId = data.appNaisId,
            workloadType = data.appWorkloadType,
            environment = data.appEnvironment,
            repository = data.appRepository,
            imageTag = data.appImageTag,
            ingressTypes = data.appIngressTypes,
            packageName = data.packageName,
            severity = data.severity,
            description = data.description,
            vulnerabilityDetailsLink = data.vulnerabilityDetailsLink,
            hasExternalIngress = data.appHasExternalIngress,
            suppressed = data.suppressed,
            discoveredAt = data.discoveredAt,
            lastSeenAt = data.lastSeenAt
        ))
        return data
    }

    override suspend fun searchVulnerabilities(
        cveId: String?,
        teamSlug: String?,
        severities: List<String>?,
        hasExternalIngress: Boolean?,
        suppressed: Boolean?,
        limit: Int,
        offset: Int
    ): Pair<List<VulnerabilitySearchResult>, Int> {
        throw NotImplementedError()
    }

    override suspend fun getActiveVulnerabilitiesForTeams(
        teamSlugs: List<String>
    ): List<VulnerabilitySearchResult> {
        getActiveVulnerabilitiesCalled = true
        lastTeamSlugs = teamSlugs
        if (throwException) {
            throw RuntimeException("Simulated database connection failure")
        }
        // Return synced data if available, otherwise return initial vulnerabilities
        return if (syncedData.isNotEmpty()) {
            syncedData.filter { it.teamSlug in teamSlugs }
        } else {
            vulnerabilities
        }
    }

    override suspend fun getAllActiveVulnerabilities(): List<VulnerabilitySearchResult> {
        return if (syncedData.isNotEmpty()) {
            syncedData
        } else {
            vulnerabilities
        }
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, currentSyncTime: Instant): Int {
        throw NotImplementedError()
    }
}

class MockNaisApiService(
    private val fallbackData: UserVulnerabilitiesData = UserVulnerabilitiesData(teams = emptyList())
) : NaisApiService {
    var getVulnerabilitiesForUserCalled = false

    override suspend fun getAllTeams(): List<TeamInfo> {
        throw NotImplementedError()
    }

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        getVulnerabilitiesForUserCalled = true
        return fallbackData
    }

    override suspend fun getVulnerabilitiesForTeam(teamSlug: String): UserVulnerabilitiesData {
        return fallbackData
    }

    override suspend fun getTeamMembershipsForUser(email: String): List<String> {
        throw NotImplementedError()
    }
}
