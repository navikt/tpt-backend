package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.user.UserContextService
import no.nav.tpt.domain.vulnerability.VulnerabilityDataService
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilitySearchResult
import no.nav.tpt.infrastructure.nais.NaisApiService
import no.nav.tpt.infrastructure.nais.TeamVulnerabilitiesData
import no.nav.tpt.infrastructure.nais.UserVulnerabilitiesData
import no.nav.tpt.infrastructure.nais.VulnerabilityData
import no.nav.tpt.infrastructure.nais.WorkloadData
import org.slf4j.LoggerFactory

class DatabaseVulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val userContextService: UserContextService,
    private val naisApiService: NaisApiService,
    private val vulnerabilityTeamSyncService: VulnerabilityTeamSyncService
) : VulnerabilityDataService {
    private val logger = LoggerFactory.getLogger(DatabaseVulnerabilityService::class.java)

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        val userContext = userContextService.getUserContext(email)
        
        if (userContext.teams.isEmpty()) {
            logger.debug("Found no teams for user $email, returning empty vulnerability data")
            return UserVulnerabilitiesData(teams = emptyList())
        }

        val teamSlugs = userContext.teams
        logger.debug("Found ${teamSlugs.size} teams for user $email")
        
        val allVulnerabilities = try {
            vulnerabilityRepository.getActiveVulnerabilitiesForTeams(teamSlugs)
        } catch (e: Exception) {
            logger.warn("Failed to fetch vulnerabilities from database for user, falling back to NAIS API: ${e.message}")
            return naisApiService.getVulnerabilitiesForUser(email)
        }

        logger.debug("Fetched vulnerabilities for user $email, vulns: ${allVulnerabilities.size}, teams: ${allVulnerabilities.distinctBy { it.teamSlug }.size}" )
        
        val syncThreshold = java.time.Instant.now().minusSeconds(30 * 60)
        val teamsNeedingSync = try {
            vulnerabilityRepository.getTeamsNeedingSync(teamSlugs, syncThreshold)
        } catch (e: Exception) {
            logger.warn("Failed to check team sync metadata: ${e.message}")
            val teamsWithData = allVulnerabilities.map { it.teamSlug }.toSet()
            teamSlugs.filterNot { it in teamsWithData }
        }
        
        if (teamsNeedingSync.isNotEmpty()) {
            logger.info("Teams needing sync: ${teamsNeedingSync.joinToString(", ")}. Syncing from NAIS API...")
            try {
                val syncStartTime = java.time.Instant.now()
                vulnerabilityTeamSyncService.syncTeams(teamsNeedingSync)
                
                teamsNeedingSync.forEach { teamSlug ->
                    try {
                        val deletedCount = vulnerabilityRepository.deleteOldDataForTeam(teamSlug, syncStartTime)
                        if (deletedCount > 0) {
                            logger.debug("Cleaned up $deletedCount stale vulnerability records for team $teamSlug during on-demand sync")
                        }
                    } catch (e: Exception) {
                        logger.warn("Failed to clean up old data for team $teamSlug during on-demand sync: ${e.message}")
                    }
                }
                
                val updatedVulnerabilities = vulnerabilityRepository.getActiveVulnerabilitiesForTeams(teamSlugs)
                return buildUserVulnerabilitiesData(teamSlugs, updatedVulnerabilities)
            } catch (e: Exception) {
                logger.warn("Failed to sync teams from NAIS API: ${e.message}. Returning partial data from database.")
            }
        }
        
        return buildUserVulnerabilitiesData(teamSlugs, allVulnerabilities)
    }
    
    private fun buildUserVulnerabilitiesData(
        teamSlugs: List<String>,
        allVulnerabilities: List<VulnerabilitySearchResult>
    ): UserVulnerabilitiesData {
        val teams = teamSlugs.map { teamSlug ->
            val teamVulns = allVulnerabilities.filter { it.teamSlug == teamSlug }
            
            val workloads = teamVulns
                .groupBy { it.applicationNaisId }
                .map { (naisId, vulns) ->
                    val firstVuln = vulns.first()
                    WorkloadData(
                        id = naisId,
                        name = firstVuln.applicationName,
                        workloadType = firstVuln.workloadType,
                        imageTag = firstVuln.imageTag,
                        repository = firstVuln.repository,
                        environment = firstVuln.environment,
                        ingressTypes = firstVuln.ingressTypes,
                        createdAt = null,
                        vulnerabilities = vulns.map { vuln ->
                            VulnerabilityData(
                                identifier = vuln.cveId,
                                severity = vuln.severity ?: "UNKNOWN",
                                packageName = vuln.packageName,
                                description = vuln.description,
                                vulnerabilityDetailsLink = vuln.vulnerabilityDetailsLink,
                                suppressed = vuln.suppressed
                            )
                        }
                    )
                }
            
            TeamVulnerabilitiesData(
                teamSlug = teamSlug,
                workloads = workloads
            )
        }.filter { it.workloads.isNotEmpty() }

        return UserVulnerabilitiesData(teams = teams)
    }
}
