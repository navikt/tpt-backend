package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.user.UserContextService
import no.nav.tpt.domain.vulnerability.VulnerabilityDataService
import no.nav.tpt.infrastructure.nais.NaisApiService
import no.nav.tpt.infrastructure.nais.TeamVulnerabilitiesData
import no.nav.tpt.infrastructure.nais.UserVulnerabilitiesData
import no.nav.tpt.infrastructure.nais.VulnerabilityData
import no.nav.tpt.infrastructure.nais.WorkloadData
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import org.slf4j.LoggerFactory

class DatabaseVulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val userContextService: UserContextService,
    private val naisApiService: NaisApiService
) : VulnerabilityDataService {
    private val logger = LoggerFactory.getLogger(DatabaseVulnerabilityService::class.java)

    override suspend fun getVulnerabilitiesForUser(email: String): UserVulnerabilitiesData {
        val userContext = userContextService.getUserContext(email)
        
        if (userContext.teams.isEmpty()) {
            return UserVulnerabilitiesData(teams = emptyList())
        }

        val teamSlugs = userContext.teams
        
        val allVulnerabilities = try {
            vulnerabilityRepository.getActiveVulnerabilitiesForTeams(teamSlugs)
        } catch (e: Exception) {
            logger.warn("Failed to fetch vulnerabilities from database for user, falling back to NAIS API: ${e.message}")
            return naisApiService.getVulnerabilitiesForUser(email)
        }
        
        if (allVulnerabilities.isEmpty()) {
            logger.info("No vulnerability data in database for user, falling back to NAIS API")
            return naisApiService.getVulnerabilitiesForUser(email)
        }
        
        val teams = teamSlugs.map { teamSlug ->
            val teamVulns = allVulnerabilities.filter { it.teamSlug == teamSlug }
            
            val workloads = teamVulns
                .groupBy { it.applicationNaisId }
                .map { (naisId, vulns) ->
                    val firstVuln = vulns.first()
                    WorkloadData(
                        id = naisId,
                        name = firstVuln.applicationName,
                        workloadType = firstVuln.workloadType,
                        imageTag = null,
                        repository = null,
                        environment = firstVuln.environment,
                        ingressTypes = emptyList(),
                        vulnerabilities = vulns.map { vuln ->
                            VulnerabilityData(
                                identifier = vuln.cveId,
                                severity = vuln.severity ?: "UNKNOWN",
                                packageName = vuln.packageName,
                                description = null,
                                vulnerabilityDetailsLink = null,
                                suppressed = vuln.suppressed
                            )
                        }
                    )
                }
            
            TeamVulnerabilitiesData(
                teamSlug = teamSlug,
                workloads = workloads
            )
        }.filter { it.workloads.isNotEmpty() }

        return UserVulnerabilitiesData(teams = teams)
    }
}
