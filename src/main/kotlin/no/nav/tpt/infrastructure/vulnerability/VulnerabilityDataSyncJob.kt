package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.delay
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.NaisApiService
import no.nav.tpt.infrastructure.nais.TeamInfo
import no.nav.tpt.plugins.LeaderElection
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant

class VulnerabilityDataSyncJob(
    private val naisApiService: NaisApiService,
    private val vulnerabilityTeamSyncService: VulnerabilityTeamSyncService,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val leaderElection: LeaderElection,
    private val teamDelayMs: Long = 3000
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityDataSyncJob::class.java)

    suspend fun syncAllTeams() {
        if (!leaderElection.isLeader()) {
            logger.debug("Not leader, skipping vulnerability data sync")
            return
        }

        logger.info("Starting vulnerability data sync")
        val syncStartTime = Instant.now()
        var teamsProcessed = 0
        var teamsFailed = 0
        var totalInserted = 0
        var totalSkipped = 0
        val allSkippedReasons = mutableMapOf<String, Int>()

        try {
            val teams = naisApiService.getAllTeams()
            logger.info("Fetched ${teams.size} teams from NAIS API")

            teams.forEach { team ->
                try {
                    val result = vulnerabilityTeamSyncService.syncTeams(
                        listOf(team.slug),
                        mapOf(team.slug to team.slackChannel)
                    ).first()
                    totalInserted += result.inserted
                    totalSkipped += result.skipped
                    result.skippedReasons.forEach { (reason, count) ->
                        allSkippedReasons[reason] = (allSkippedReasons[reason] ?: 0) + count
                    }
                    teamsProcessed++
                    
                    if (result.skipped > 0) {
                        logger.info("Team ${team.slug}: ${result.inserted} inserted, ${result.skipped} skipped")
                    }
                    
                    delay(teamDelayMs)
                } catch (e: Exception) {
                    logger.error("Failed to sync team ${team.slug}", e)
                    teamsFailed++
                }
            }

            // Clean up stale data for all teams
            teams.forEach { team ->
                try {
                    val deletedCount = vulnerabilityRepository.deleteOldDataForTeam(team.slug, syncStartTime)
                    if (deletedCount > 0) {
                        logger.debug("Cleaned up $deletedCount stale vulnerability records for team ${team.slug}")
                    }
                } catch (e: Exception) {
                    logger.warn("Failed to clean up old data for team ${team.slug}", e)
                }
            }

            val duration = Duration.between(syncStartTime, Instant.now())
            val summary = buildString {
                append("Sync completed: $teamsProcessed teams, $totalInserted inserted, $totalSkipped skipped, $teamsFailed failed")
                if (allSkippedReasons.isNotEmpty()) {
                    append(" (reasons: ${allSkippedReasons.entries.joinToString { "${it.key}=${it.value}" }})")
                }
                append(", duration: ${duration.toMinutes()}m")
            }
            logger.info(summary)

        } catch (e: Exception) {
            logger.error("Vulnerability data sync failed", e)
            throw e
        }
    }

}
