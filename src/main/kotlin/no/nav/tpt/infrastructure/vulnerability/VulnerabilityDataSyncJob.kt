package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.delay
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.NaisApiService
import no.nav.tpt.infrastructure.nais.TeamInfo
import no.nav.tpt.plugins.LeaderElection
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant

class VulnerabilityDataSyncJob(
    private val naisApiService: NaisApiService,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val leaderElection: LeaderElection,
    private val teamDelayMs: Long = 3000
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityDataSyncJob::class.java)

    private data class TeamSyncResult(
        val processed: Int,
        val inserted: Int,
        val skipped: Int,
        val skippedReasons: Map<String, Int>
    )

    suspend fun syncAllTeams() {
        if (!leaderElection.isLeader()) {
            logger.debug("Not leader, skipping vulnerability data sync")
            return
        }

        logger.info("Starting vulnerability data sync")
        val syncStartTime = Instant.now()
        var teamsProcessed = 0
        var teamsFailed = 0
        var totalInserted = 0
        var totalSkipped = 0
        val allSkippedReasons = mutableMapOf<String, Int>()

        try {
            val teams = naisApiService.getAllTeams()
            logger.info("Fetched ${teams.size} teams from NAIS API")

            teams.forEach { team ->
                try {
                    val result = syncTeam(team, syncStartTime)
                    totalInserted += result.inserted
                    totalSkipped += result.skipped
                    result.skippedReasons.forEach { (reason, count) ->
                        allSkippedReasons[reason] = (allSkippedReasons[reason] ?: 0) + count
                    }
                    teamsProcessed++
                    
                    if (result.skipped > 0) {
                        logger.info("Team ${team.slug}: ${result.inserted} inserted, ${result.skipped} skipped")
                    }
                    
                    delay(teamDelayMs)
                } catch (e: Exception) {
                    logger.error("Failed to sync team ${team.slug}", e)
                    teamsFailed++
                }
            }

            // Clean up stale data for all teams
            teams.forEach { team ->
                try {
                    val deletedCount = vulnerabilityRepository.deleteOldDataForTeam(team.slug, syncStartTime)
                    if (deletedCount > 0) {
                        logger.debug("Cleaned up $deletedCount stale vulnerability records for team ${team.slug}")
                    }
                } catch (e: Exception) {
                    logger.warn("Failed to clean up old data for team ${team.slug}", e)
                }
            }

            val duration = Duration.between(syncStartTime, Instant.now())
            val summary = buildString {
                append("Sync completed: $teamsProcessed teams, $totalInserted inserted, $totalSkipped skipped, $teamsFailed failed")
                if (allSkippedReasons.isNotEmpty()) {
                    append(" (reasons: ${allSkippedReasons.entries.joinToString { "${it.key}=${it.value}" }})")
                }
                append(", duration: ${duration.toMinutes()}m")
            }
            logger.info(summary)

        } catch (e: Exception) {
            logger.error("Vulnerability data sync failed", e)
            throw e
        }
    }

    private suspend fun syncTeam(team: TeamInfo, syncTime: Instant): TeamSyncResult {
        var processed = 0
        var inserted = 0
        var skipped = 0
        val skippedReasons = mutableMapOf<String, Int>()
        
        val vulnerabilityData = naisApiService.getVulnerabilitiesForTeam(team.slug)

        vulnerabilityData.teams.forEach { teamVulnData ->
            teamVulnData.workloads.forEach { workload ->
                workload.vulnerabilities.forEach { vuln ->
                    processed++
                    
                    val trackingData = VulnerabilityTrackingData(
                        id = null,
                        // Team context
                        teamSlug = team.slug,
                        teamSlackChannel = team.slackChannel,
                        // Application context
                        appNaisId = workload.id,
                        appName = workload.name,
                        appWorkloadType = workload.workloadType,
                        appEnvironment = workload.environment,
                        appRepository = workload.repository,
                        appImageName = extractImageName(workload.imageTag),
                        appImageTag = workload.imageTag,
                        appHasExternalIngress = workload.ingressTypes.any { it.equals("external", ignoreCase = true) },
                        appIngressTypes = workload.ingressTypes,
                        // Vulnerability data
                        cveId = vuln.identifier,
                        packageName = vuln.packageName,
                        severity = vuln.severity,
                        description = vuln.description,
                        vulnerabilityDetailsLink = vuln.vulnerabilityDetailsLink,
                        suppressed = vuln.suppressed,
                        // Timestamps
                        discoveredAt = syncTime,
                        lastSeenAt = syncTime,
                        resolvedAt = null,
                        syncTimestamp = syncTime
                    )
                    
                    val validationResult = validateVulnerabilityData(trackingData)
                    if (validationResult.isNotEmpty()) {
                        skipped++
                        validationResult.forEach { reason ->
                            skippedReasons[reason] = (skippedReasons[reason] ?: 0) + 1
                        }
                        logger.warn("Skipping vulnerability for team ${team.slug}, app ${workload.name}, CVE ${vuln.identifier}: ${validationResult.joinToString()}")
                        return@forEach
                    }
                    
                    try {
                        vulnerabilityRepository.upsertVulnerability(trackingData)
                        inserted++
                        logger.debug("Upserted vulnerability ${vuln.identifier} for team ${team.slug}, app ${workload.name}")
                    } catch (e: Exception) {
                        skipped++
                        val reason = categorizeError(e)
                        skippedReasons[reason] = (skippedReasons[reason] ?: 0) + 1
                        logger.warn("Failed to upsert vulnerability ${vuln.identifier} for team ${team.slug}, app ${workload.name}: ${e.message}")
                    }
                }
            }
        }

        return TeamSyncResult(processed, inserted, skipped, skippedReasons)
    }
    
    private fun validateVulnerabilityData(data: VulnerabilityTrackingData): List<String> {
        val errors = mutableListOf<String>()
        
        if (data.cveId.length > 50) {
            errors.add("cve_id_too_long")
        }
        if (data.teamSlug.length > 100) {
            errors.add("team_slug_too_long")
        }
        if (data.appName.length > 255) {
            errors.add("app_name_too_long")
        }
        if (data.packageName != null && data.packageName.length > 255) {
            errors.add("package_name_too_long")
        }
        if (data.appImageName != null && data.appImageName.length > 500) {
            errors.add("image_name_too_long")
        }
        if (data.appImageTag != null && data.appImageTag.length > 500) {
            errors.add("image_tag_too_long")
        }
        if (data.severity != null && data.severity.length > 20) {
            errors.add("severity_too_long")
        }
        
        return errors
    }
    
    private fun categorizeError(e: Exception): String {
        val message = e.message ?: ""
        return when {
            message.contains("constraint", ignoreCase = true) -> "constraint_violation"
            message.contains("duplicate", ignoreCase = true) -> "duplicate_key"
            message.contains("foreign key", ignoreCase = true) -> "foreign_key_violation"
            message.contains("data too long", ignoreCase = true) -> "data_too_long"
            else -> "database_error"
        }
    }

    private fun extractImageName(imageTag: String?): String? {
        if (imageTag == null) return null
        return imageTag.substringBeforeLast(':')
    }
}
