package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.delay
import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.NaisApiService
import no.nav.tpt.infrastructure.nais.TeamInfo
import no.nav.tpt.plugins.LeaderElection
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant

class VulnerabilityDataSyncJob(
    private val naisApiService: NaisApiService,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val leaderElection: LeaderElection,
    private val teamDelayMs: Long = 3000
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityDataSyncJob::class.java)

    suspend fun syncAllTeams() {
        if (!leaderElection.isLeader()) {
            logger.debug("Not leader, skipping vulnerability data sync")
            return
        }

        logger.info("Starting vulnerability data sync")
        val syncStartTime = Instant.now()
        var teamsProcessed = 0
        var teamsFailed = 0
        var totalVulnerabilities = 0

        try {
            val teams = naisApiService.getAllTeams()
            logger.info("Fetched ${teams.size} teams from NAIS API")

            teams.forEach { team ->
                try {
                    val vulnCount = syncTeam(team, syncStartTime)
                    totalVulnerabilities += vulnCount
                    teamsProcessed++
                    delay(teamDelayMs)
                } catch (e: Exception) {
                    logger.error("Failed to sync team ${team.slug}", e)
                    teamsFailed++
                }
            }

            // Clean up stale data for all teams
            teams.forEach { team ->
                try {
                    val deletedCount = vulnerabilityRepository.deleteOldDataForTeam(team.slug, syncStartTime)
                    if (deletedCount > 0) {
                        logger.debug("Cleaned up $deletedCount stale vulnerability records for team ${team.slug}")
                    }
                } catch (e: Exception) {
                    logger.warn("Failed to clean up old data for team ${team.slug}", e)
                }
            }

            val duration = Duration.between(syncStartTime, Instant.now())
            logger.info("Sync completed: $teamsProcessed teams, $totalVulnerabilities vulnerabilities, $teamsFailed failed, duration: ${duration.toMinutes()}m")

        } catch (e: Exception) {
            logger.error("Vulnerability data sync failed", e)
            throw e
        }
    }

    private suspend fun syncTeam(team: TeamInfo, syncTime: Instant): Int {
        var vulnerabilityCount = 0
        
        val vulnerabilityData = naisApiService.getVulnerabilitiesForTeam(team.slug)

        vulnerabilityData.teams.forEach { teamVulnData ->
            teamVulnData.workloads.forEach { workload ->
                workload.vulnerabilities.forEach { vuln ->
                    vulnerabilityRepository.upsertVulnerability(
                        VulnerabilityTrackingData(
                            id = null,
                            // Team context
                            teamSlug = team.slug,
                            teamSlackChannel = team.slackChannel,
                            // Application context
                            appNaisId = workload.id,
                            appName = workload.name,
                            appWorkloadType = workload.workloadType,
                            appEnvironment = workload.environment,
                            appRepository = workload.repository,
                            appImageName = extractImageName(workload.imageTag),
                            appImageTag = workload.imageTag,
                            appHasExternalIngress = workload.ingressTypes.any { it.equals("external", ignoreCase = true) },
                            appIngressTypes = workload.ingressTypes,
                            // Vulnerability data
                            cveId = vuln.identifier,
                            packageName = vuln.packageName,
                            severity = vuln.severity,
                            description = vuln.description,
                            vulnerabilityDetailsLink = vuln.vulnerabilityDetailsLink,
                            suppressed = vuln.suppressed,
                            // Timestamps
                            discoveredAt = syncTime,
                            lastSeenAt = syncTime,
                            resolvedAt = null,
                            syncTimestamp = syncTime
                        )
                    )
                    vulnerabilityCount++
                }
            }
        }

        return vulnerabilityCount
    }

    private fun extractImageName(imageTag: String?): String? {
        if (imageTag == null) return null
        return imageTag.substringBeforeLast(':')
    }
}
