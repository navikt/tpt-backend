package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.Dispatchers
import no.nav.tpt.domain.vulnerability.*
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.SqlExpressionBuilder.inList
import org.jetbrains.exposed.sql.SqlExpressionBuilder.isNull
import org.jetbrains.exposed.sql.SqlExpressionBuilder.less
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
import java.time.Instant

class VulnerabilityRepositoryImpl : VulnerabilityRepository {

    private suspend fun <T> dbQuery(block: suspend () -> T): T =
        newSuspendedTransaction(Dispatchers.IO) { block() }

    override suspend fun upsertVulnerability(vulnerability: VulnerabilityTrackingData): VulnerabilityTrackingData = dbQuery {
        val now = Instant.now()
        
        val existing = VulnerabilityTracking.selectAll()
            .where {
                (VulnerabilityTracking.appNaisId eq vulnerability.appNaisId) and
                (VulnerabilityTracking.cveId eq vulnerability.cveId) and
                (VulnerabilityTracking.packageName eq vulnerability.packageName)
            }
            .singleOrNull()

        if (existing != null) {
            val existingId = existing[VulnerabilityTracking.id]
            VulnerabilityTracking.update({ VulnerabilityTracking.id eq existingId }) {
                it[lastSeenAt] = vulnerability.lastSeenAt
                it[syncTimestamp] = vulnerability.syncTimestamp
                it[resolvedAt] = vulnerability.resolvedAt
                it[suppressed] = vulnerability.suppressed
                it[severity] = vulnerability.severity
                it[description] = vulnerability.description
                it[vulnerabilityDetailsLink] = vulnerability.vulnerabilityDetailsLink
                it[updatedAt] = now
            }
            vulnerability.copy(id = existingId)
        } else {
            val id = VulnerabilityTracking.insert {
                it[teamSlug] = vulnerability.teamSlug
                it[teamSlackChannel] = vulnerability.teamSlackChannel
                it[appNaisId] = vulnerability.appNaisId
                it[appName] = vulnerability.appName
                it[appWorkloadType] = vulnerability.appWorkloadType
                it[appEnvironment] = vulnerability.appEnvironment
                it[appRepository] = vulnerability.appRepository
                it[appImageName] = vulnerability.appImageName
                it[appImageTag] = vulnerability.appImageTag
                it[appHasExternalIngress] = vulnerability.appHasExternalIngress
                it[appIngressTypes] = vulnerability.appIngressTypes
                it[cveId] = vulnerability.cveId
                it[packageName] = vulnerability.packageName
                it[severity] = vulnerability.severity
                it[description] = vulnerability.description
                it[vulnerabilityDetailsLink] = vulnerability.vulnerabilityDetailsLink
                it[suppressed] = vulnerability.suppressed
                it[discoveredAt] = vulnerability.discoveredAt
                it[lastSeenAt] = vulnerability.lastSeenAt
                it[resolvedAt] = vulnerability.resolvedAt
                it[syncTimestamp] = vulnerability.syncTimestamp
                it[createdAt] = now
                it[updatedAt] = now
            }[VulnerabilityTracking.id]
            vulnerability.copy(id = id)
        }
    }

    override suspend fun searchVulnerabilities(
        cveId: String?,
        teamSlug: String?,
        severities: List<String>?,
        hasExternalIngress: Boolean?,
        suppressed: Boolean?,
        limit: Int,
        offset: Int
    ): Pair<List<VulnerabilitySearchResult>, Int> = dbQuery {
        val query = VulnerabilityTracking.selectAll()
            .where { VulnerabilityTracking.resolvedAt.isNull() }

        cveId?.let { query.andWhere { VulnerabilityTracking.cveId eq it } }
        teamSlug?.let { query.andWhere { VulnerabilityTracking.teamSlug eq it } }
        severities?.let { if (it.isNotEmpty()) query.andWhere { VulnerabilityTracking.severity inList it } }
        hasExternalIngress?.let { query.andWhere { VulnerabilityTracking.appHasExternalIngress eq it } }
        suppressed?.let { query.andWhere { VulnerabilityTracking.suppressed eq it } }

        val totalCount = query.count().toInt()

        val results = query
            .orderBy(VulnerabilityTracking.discoveredAt to SortOrder.ASC)
            .toList()
            .drop(offset)
            .take(limit)
            .map { it.toVulnerabilitySearchResult() }

        results to totalCount
    }

    override suspend fun getActiveVulnerabilitiesForTeams(teamSlugs: List<String>): List<VulnerabilitySearchResult> = dbQuery {
        VulnerabilityTracking.selectAll()
            .where {
                (VulnerabilityTracking.resolvedAt.isNull()) and
                (VulnerabilityTracking.suppressed eq false) and
                (VulnerabilityTracking.teamSlug inList teamSlugs)
            }
            .orderBy(VulnerabilityTracking.discoveredAt to SortOrder.ASC)
            .map { it.toVulnerabilitySearchResult() }
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, beforeTimestamp: Instant): Int = dbQuery {
        VulnerabilityTracking.deleteWhere {
            (VulnerabilityTracking.teamSlug eq teamSlug) and
            (VulnerabilityTracking.syncTimestamp less beforeTimestamp)
        }
    }

    private fun ResultRow.toVulnerabilitySearchResult() = VulnerabilitySearchResult(
        cveId = this[VulnerabilityTracking.cveId],
        teamSlug = this[VulnerabilityTracking.teamSlug],
        applicationName = this[VulnerabilityTracking.appName],
        applicationNaisId = this[VulnerabilityTracking.appNaisId],
        workloadType = this[VulnerabilityTracking.appWorkloadType],
        environment = this[VulnerabilityTracking.appEnvironment],
        packageName = this[VulnerabilityTracking.packageName],
        severity = this[VulnerabilityTracking.severity],
        hasExternalIngress = this[VulnerabilityTracking.appHasExternalIngress],
        suppressed = this[VulnerabilityTracking.suppressed],
        discoveredAt = this[VulnerabilityTracking.discoveredAt],
        lastSeenAt = this[VulnerabilityTracking.lastSeenAt]
    )
}
