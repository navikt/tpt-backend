package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.Dispatchers
import no.nav.tpt.domain.vulnerability.*
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.SqlExpressionBuilder.inList
import org.jetbrains.exposed.sql.SqlExpressionBuilder.isNull
import org.jetbrains.exposed.sql.SqlExpressionBuilder.less
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
import org.slf4j.LoggerFactory
import java.time.Instant

class VulnerabilityRepositoryImpl : VulnerabilityRepository {
    private val logger = LoggerFactory.getLogger(VulnerabilityRepositoryImpl::class.java)

    private suspend fun <T> dbQuery(block: suspend () -> T): T =
        newSuspendedTransaction(Dispatchers.IO) { block() }

    override suspend fun upsertVulnerability(vulnerability: VulnerabilityTrackingData): VulnerabilityTrackingData = dbQuery {
        val now = Instant.now()
        
        try {
            // 1. Upsert CVE first
            Cves.upsert(Cves.id) {
                it[id] = vulnerability.cveId
                it[severity] = vulnerability.severity
                it[description] = vulnerability.description
                it[vulnerabilityDetailsLink] = vulnerability.vulnerabilityDetailsLink
                it[updatedAt] = now
            }
            
            // 2. Check if workload vulnerability exists
            val existing = WorkloadVulnerabilities.selectAll()
                .where {
                    (WorkloadVulnerabilities.appNaisId eq vulnerability.appNaisId) and
                    (WorkloadVulnerabilities.cveId eq vulnerability.cveId) and
                    (WorkloadVulnerabilities.packageName eq vulnerability.packageName)
                }
                .singleOrNull()

            if (existing != null) {
                val existingId = existing[WorkloadVulnerabilities.id]
                WorkloadVulnerabilities.update({ WorkloadVulnerabilities.id eq existingId }) {
                    it[lastSeenAt] = vulnerability.lastSeenAt
                    it[syncTimestamp] = vulnerability.syncTimestamp
                    it[resolvedAt] = vulnerability.resolvedAt
                    it[suppressed] = vulnerability.suppressed
                    it[updatedAt] = now
                }
                logger.debug("Updated existing vulnerability: CVE ${vulnerability.cveId} for app ${vulnerability.appName}")
                vulnerability.copy(id = existingId)
            } else {
                val id = WorkloadVulnerabilities.insert {
                    it[teamSlug] = vulnerability.teamSlug
                    it[teamSlackChannel] = vulnerability.teamSlackChannel
                    it[appNaisId] = vulnerability.appNaisId
                    it[appName] = vulnerability.appName
                    it[appWorkloadType] = vulnerability.appWorkloadType
                    it[appEnvironment] = vulnerability.appEnvironment
                    it[appRepository] = vulnerability.appRepository
                    it[appImageName] = vulnerability.appImageName
                    it[appImageTag] = vulnerability.appImageTag
                    it[appHasExternalIngress] = vulnerability.appHasExternalIngress
                    it[appIngressTypes] = vulnerability.appIngressTypes
                    it[cveId] = vulnerability.cveId
                    it[packageName] = vulnerability.packageName
                    it[suppressed] = vulnerability.suppressed
                    it[discoveredAt] = vulnerability.discoveredAt
                    it[lastSeenAt] = vulnerability.lastSeenAt
                    it[resolvedAt] = vulnerability.resolvedAt
                    it[syncTimestamp] = vulnerability.syncTimestamp
                    it[createdAt] = now
                    it[updatedAt] = now
                }[WorkloadVulnerabilities.id]
                logger.debug("Inserted new vulnerability: CVE ${vulnerability.cveId} for app ${vulnerability.appName}")
                vulnerability.copy(id = id)
            }
        } catch (e: Exception) {
            logger.error("Database error upserting vulnerability CVE ${vulnerability.cveId} for app ${vulnerability.appName}: ${e.message}")
            throw e
        }
    }

    override suspend fun searchVulnerabilities(
        cveId: String?,
        teamSlug: String?,
        severities: List<String>?,
        hasExternalIngress: Boolean?,
        suppressed: Boolean?,
        limit: Int,
        offset: Int
    ): Pair<List<VulnerabilitySearchResult>, Int> = try {
        dbQuery {
            val query = (WorkloadVulnerabilities innerJoin Cves)
                .selectAll()
                .where { WorkloadVulnerabilities.resolvedAt.isNull() }

            cveId?.let { query.andWhere { WorkloadVulnerabilities.cveId eq it } }
            teamSlug?.let { query.andWhere { WorkloadVulnerabilities.teamSlug eq it } }
            severities?.let { if (it.isNotEmpty()) query.andWhere { Cves.severity inList it } }
            hasExternalIngress?.let { query.andWhere { WorkloadVulnerabilities.appHasExternalIngress eq it } }
            suppressed?.let { query.andWhere { WorkloadVulnerabilities.suppressed eq it } }

            val totalCount = query.count().toInt()

            val results = query
                .orderBy(WorkloadVulnerabilities.discoveredAt to SortOrder.ASC)
                .toList()
                .drop(offset)
                .take(limit)
                .map { it.toVulnerabilitySearchResult() }

            results to totalCount
        }
    } catch (e: Exception) {
        logger.error("Database error searching vulnerabilities: ${e.message}")
        throw e
    }

    override suspend fun getActiveVulnerabilitiesForTeams(teamSlugs: List<String>): List<VulnerabilitySearchResult> = try {
        dbQuery {
            (WorkloadVulnerabilities innerJoin Cves)
                .selectAll()
                .where {
                    (WorkloadVulnerabilities.resolvedAt.isNull()) and
                    (WorkloadVulnerabilities.suppressed eq false) and
                    (WorkloadVulnerabilities.teamSlug inList teamSlugs)
                }
                .orderBy(WorkloadVulnerabilities.discoveredAt to SortOrder.ASC)
                .map { it.toVulnerabilitySearchResult() }
        }
    } catch (e: Exception) {
        logger.error("Database error fetching active vulnerabilities for teams: ${e.message}")
        throw e
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, beforeTimestamp: Instant): Int = try {
        dbQuery {
            // 1. Delete old workload vulnerabilities
            val deletedCount = WorkloadVulnerabilities.deleteWhere {
                (WorkloadVulnerabilities.teamSlug eq teamSlug) and
                (WorkloadVulnerabilities.syncTimestamp less beforeTimestamp)
            }
            
            // 2. Clean up orphaned CVEs (CVEs with no remaining workload references)
            val orphanedCveIds = Cves.selectAll()
                .where { 
                    Cves.id notInSubQuery(
                        WorkloadVulnerabilities
                            .select(WorkloadVulnerabilities.cveId)
                            .withDistinct()
                    )
                }
                .map { it[Cves.id] }
            
            if (orphanedCveIds.isNotEmpty()) {
                Cves.deleteWhere { id inList orphanedCveIds }
                logger.debug("Cleaned up ${orphanedCveIds.size} orphaned CVEs for team $teamSlug")
            }
            
            deletedCount
        }
    } catch (e: Exception) {
        logger.error("Database error deleting old data for team $teamSlug: ${e.message}")
        throw e
    }

    private fun ResultRow.toVulnerabilitySearchResult() = VulnerabilitySearchResult(
        cveId = this[WorkloadVulnerabilities.cveId],
        teamSlug = this[WorkloadVulnerabilities.teamSlug],
        applicationName = this[WorkloadVulnerabilities.appName],
        applicationNaisId = this[WorkloadVulnerabilities.appNaisId],
        workloadType = this[WorkloadVulnerabilities.appWorkloadType],
        environment = this[WorkloadVulnerabilities.appEnvironment],
        repository = this[WorkloadVulnerabilities.appRepository],
        imageTag = this[WorkloadVulnerabilities.appImageTag],
        ingressTypes = this[WorkloadVulnerabilities.appIngressTypes] ?: emptyList(),
        packageName = this[WorkloadVulnerabilities.packageName],
        severity = this[Cves.severity],
        description = this[Cves.description],
        vulnerabilityDetailsLink = this[Cves.vulnerabilityDetailsLink],
        hasExternalIngress = this[WorkloadVulnerabilities.appHasExternalIngress],
        suppressed = this[WorkloadVulnerabilities.suppressed],
        discoveredAt = this[WorkloadVulnerabilities.discoveredAt],
        lastSeenAt = this[WorkloadVulnerabilities.lastSeenAt]
    )
}
