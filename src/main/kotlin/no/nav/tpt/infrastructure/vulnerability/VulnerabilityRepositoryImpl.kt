package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.Dispatchers
import no.nav.tpt.domain.vulnerability.*
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.SqlExpressionBuilder.inList
import org.jetbrains.exposed.sql.SqlExpressionBuilder.isNull
import org.jetbrains.exposed.sql.SqlExpressionBuilder.less
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
import java.time.Instant

class VulnerabilityRepositoryImpl : VulnerabilityRepository {

    private suspend fun <T> dbQuery(block: suspend () -> T): T =
        newSuspendedTransaction(Dispatchers.IO) { block() }

    override suspend fun upsertVulnerability(vulnerability: VulnerabilityTrackingData): VulnerabilityTrackingData = dbQuery {
        val now = Instant.now()
        
        // 1. Upsert CVE first
        Cves.upsert(Cves.id) {
            it[id] = vulnerability.cveId
            it[severity] = vulnerability.severity
            it[description] = vulnerability.description
            it[vulnerabilityDetailsLink] = vulnerability.vulnerabilityDetailsLink
            it[updatedAt] = now
        }
        
        // 2. Check if workload vulnerability exists
        val existing = WorkloadVulnerabilities.selectAll()
            .where {
                (WorkloadVulnerabilities.appNaisId eq vulnerability.appNaisId) and
                (WorkloadVulnerabilities.cveId eq vulnerability.cveId) and
                (WorkloadVulnerabilities.packageName eq vulnerability.packageName)
            }
            .singleOrNull()

        if (existing != null) {
            val existingId = existing[WorkloadVulnerabilities.id]
            WorkloadVulnerabilities.update({ WorkloadVulnerabilities.id eq existingId }) {
                it[lastSeenAt] = vulnerability.lastSeenAt
                it[syncTimestamp] = vulnerability.syncTimestamp
                it[resolvedAt] = vulnerability.resolvedAt
                it[suppressed] = vulnerability.suppressed
                it[updatedAt] = now
            }
            vulnerability.copy(id = existingId)
        } else {
            val id = WorkloadVulnerabilities.insert {
                it[teamSlug] = vulnerability.teamSlug
                it[teamSlackChannel] = vulnerability.teamSlackChannel
                it[appNaisId] = vulnerability.appNaisId
                it[appName] = vulnerability.appName
                it[appWorkloadType] = vulnerability.appWorkloadType
                it[appEnvironment] = vulnerability.appEnvironment
                it[appRepository] = vulnerability.appRepository
                it[appImageName] = vulnerability.appImageName
                it[appImageTag] = vulnerability.appImageTag
                it[appHasExternalIngress] = vulnerability.appHasExternalIngress
                it[appIngressTypes] = vulnerability.appIngressTypes
                it[cveId] = vulnerability.cveId
                it[packageName] = vulnerability.packageName
                it[suppressed] = vulnerability.suppressed
                it[discoveredAt] = vulnerability.discoveredAt
                it[lastSeenAt] = vulnerability.lastSeenAt
                it[resolvedAt] = vulnerability.resolvedAt
                it[syncTimestamp] = vulnerability.syncTimestamp
                it[createdAt] = now
                it[updatedAt] = now
            }[WorkloadVulnerabilities.id]
            vulnerability.copy(id = id)
        }
    }

    override suspend fun searchVulnerabilities(
        cveId: String?,
        teamSlug: String?,
        severities: List<String>?,
        hasExternalIngress: Boolean?,
        suppressed: Boolean?,
        limit: Int,
        offset: Int
    ): Pair<List<VulnerabilitySearchResult>, Int> = dbQuery {
        val query = (WorkloadVulnerabilities innerJoin Cves)
            .selectAll()
            .where { WorkloadVulnerabilities.resolvedAt.isNull() }

        cveId?.let { query.andWhere { WorkloadVulnerabilities.cveId eq it } }
        teamSlug?.let { query.andWhere { WorkloadVulnerabilities.teamSlug eq it } }
        severities?.let { if (it.isNotEmpty()) query.andWhere { Cves.severity inList it } }
        hasExternalIngress?.let { query.andWhere { WorkloadVulnerabilities.appHasExternalIngress eq it } }
        suppressed?.let { query.andWhere { WorkloadVulnerabilities.suppressed eq it } }

        val totalCount = query.count().toInt()

        val results = query
            .orderBy(WorkloadVulnerabilities.discoveredAt to SortOrder.ASC)
            .toList()
            .drop(offset)
            .take(limit)
            .map { it.toVulnerabilitySearchResult() }

        results to totalCount
    }

    override suspend fun getActiveVulnerabilitiesForTeams(teamSlugs: List<String>): List<VulnerabilitySearchResult> = dbQuery {
        (WorkloadVulnerabilities innerJoin Cves)
            .selectAll()
            .where {
                (WorkloadVulnerabilities.resolvedAt.isNull()) and
                (WorkloadVulnerabilities.suppressed eq false) and
                (WorkloadVulnerabilities.teamSlug inList teamSlugs)
            }
            .orderBy(WorkloadVulnerabilities.discoveredAt to SortOrder.ASC)
            .map { it.toVulnerabilitySearchResult() }
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, beforeTimestamp: Instant): Int = dbQuery {
        // 1. Delete old workload vulnerabilities
        val deletedCount = WorkloadVulnerabilities.deleteWhere {
            (WorkloadVulnerabilities.teamSlug eq teamSlug) and
            (WorkloadVulnerabilities.syncTimestamp less beforeTimestamp)
        }
        
        // 2. Clean up orphaned CVEs (CVEs with no remaining workload references)
        val orphanedCveIds = Cves.selectAll()
            .where { 
                Cves.id notInSubQuery(
                    WorkloadVulnerabilities
                        .select(WorkloadVulnerabilities.cveId)
                        .withDistinct()
                )
            }
            .map { it[Cves.id] }
        
        if (orphanedCveIds.isNotEmpty()) {
            Cves.deleteWhere { id inList orphanedCveIds }
        }
        
        deletedCount
    }

    private fun ResultRow.toVulnerabilitySearchResult() = VulnerabilitySearchResult(
        cveId = this[WorkloadVulnerabilities.cveId],
        teamSlug = this[WorkloadVulnerabilities.teamSlug],
        applicationName = this[WorkloadVulnerabilities.appName],
        applicationNaisId = this[WorkloadVulnerabilities.appNaisId],
        workloadType = this[WorkloadVulnerabilities.appWorkloadType],
        environment = this[WorkloadVulnerabilities.appEnvironment],
        packageName = this[WorkloadVulnerabilities.packageName],
        severity = this[Cves.severity],
        hasExternalIngress = this[WorkloadVulnerabilities.appHasExternalIngress],
        suppressed = this[WorkloadVulnerabilities.suppressed],
        discoveredAt = this[WorkloadVulnerabilities.discoveredAt],
        lastSeenAt = this[WorkloadVulnerabilities.lastSeenAt]
    )
}
