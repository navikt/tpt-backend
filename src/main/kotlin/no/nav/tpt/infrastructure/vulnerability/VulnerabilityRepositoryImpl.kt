package no.nav.tpt.infrastructure.vulnerability

import kotlinx.coroutines.Dispatchers
import no.nav.tpt.domain.vulnerability.*
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.SqlExpressionBuilder.greaterEq
import org.jetbrains.exposed.sql.SqlExpressionBuilder.inList
import org.jetbrains.exposed.sql.SqlExpressionBuilder.isNull
import org.jetbrains.exposed.sql.SqlExpressionBuilder.less
import org.jetbrains.exposed.sql.statements.api.ExposedBlob
import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
import org.jetbrains.exposed.sql.transactions.transaction
import org.slf4j.LoggerFactory
import java.time.Instant

class VulnerabilityRepositoryImpl : VulnerabilityRepository {
    private val logger = LoggerFactory.getLogger(VulnerabilityRepositoryImpl::class.java)

    private suspend fun <T> dbQuery(block: suspend () -> T): T =
        newSuspendedTransaction(Dispatchers.IO) { block() }

    override suspend fun upsertVulnerability(vulnerability: VulnerabilityTrackingData): VulnerabilityTrackingData = dbQuery {
        val now = Instant.now()
        
        try {
            // 1. Upsert CVE first
            Cves.upsert(Cves.id) {
                it[id] = vulnerability.cveId
                it[severity] = vulnerability.severity
                it[description] = vulnerability.description
                it[vulnerabilityDetailsLink] = vulnerability.vulnerabilityDetailsLink
                it[updatedAt] = now
            }
            
            // 2. Check if workload vulnerability exists
            val existing = WorkloadVulnerabilities.selectAll()
                .where {
                    (WorkloadVulnerabilities.appNaisId eq vulnerability.appNaisId) and
                    (WorkloadVulnerabilities.cveId eq vulnerability.cveId) and
                    (WorkloadVulnerabilities.packageName eq vulnerability.packageName)
                }
                .singleOrNull()

            if (existing != null) {
                val existingId = existing[WorkloadVulnerabilities.id]
                WorkloadVulnerabilities.update({ WorkloadVulnerabilities.id eq existingId }) {
                    it[lastSeenAt] = vulnerability.lastSeenAt
                    it[syncTimestamp] = vulnerability.syncTimestamp
                    it[resolvedAt] = vulnerability.resolvedAt
                    it[suppressed] = vulnerability.suppressed
                    it[updatedAt] = now
                }
                logger.debug("Updated existing vulnerability: CVE ${vulnerability.cveId} for app ${vulnerability.appName}")
                vulnerability.copy(id = existingId)
            } else {
                val id = WorkloadVulnerabilities.insert {
                    it[teamSlug] = vulnerability.teamSlug
                    it[teamSlackChannel] = vulnerability.teamSlackChannel
                    it[appNaisId] = vulnerability.appNaisId
                    it[appName] = vulnerability.appName
                    it[appWorkloadType] = vulnerability.appWorkloadType
                    it[appEnvironment] = vulnerability.appEnvironment
                    it[appRepository] = vulnerability.appRepository
                    it[appImageName] = vulnerability.appImageName
                    it[appImageTag] = vulnerability.appImageTag
                    it[appHasExternalIngress] = vulnerability.appHasExternalIngress
                    it[appIngressTypes] = vulnerability.appIngressTypes
                    it[cveId] = vulnerability.cveId
                    it[packageName] = vulnerability.packageName
                    it[suppressed] = vulnerability.suppressed
                    it[discoveredAt] = vulnerability.discoveredAt
                    it[lastSeenAt] = vulnerability.lastSeenAt
                    it[resolvedAt] = vulnerability.resolvedAt
                    it[syncTimestamp] = vulnerability.syncTimestamp
                    it[createdAt] = now
                    it[updatedAt] = now
                }[WorkloadVulnerabilities.id]
                logger.debug("Inserted new vulnerability: CVE ${vulnerability.cveId} for app ${vulnerability.appName}")
                vulnerability.copy(id = id)
            }
        } catch (e: Exception) {
            logger.error("Database error upserting vulnerability CVE ${vulnerability.cveId} for app ${vulnerability.appName}: ${e.message}")
            throw e
        }
    }

    override suspend fun getActiveVulnerabilitiesForTeams(teamSlugs: List<String>): List<VulnerabilitySearchResult> = try {
        dbQuery {
            (WorkloadVulnerabilities innerJoin Cves)
                .selectAll()
                .where {
                    (WorkloadVulnerabilities.resolvedAt.isNull()) and
                    (WorkloadVulnerabilities.suppressed eq false) and
                    (WorkloadVulnerabilities.teamSlug inList teamSlugs)
                }
                .orderBy(WorkloadVulnerabilities.discoveredAt to SortOrder.ASC)
                .map { it.toVulnerabilitySearchResult() }
        }
    } catch (e: Exception) {
        logger.error("Database error fetching active vulnerabilities for teams: ${e.message}")
        throw e
    }

    override suspend fun deleteOldDataForTeam(teamSlug: String, beforeTimestamp: Instant): Int = try {
        dbQuery {
            // 1. Delete old workload vulnerabilities
            val deletedCount = WorkloadVulnerabilities.deleteWhere {
                (WorkloadVulnerabilities.teamSlug eq teamSlug) and
                (WorkloadVulnerabilities.syncTimestamp less beforeTimestamp)
            }
            
            // 2. Clean up orphaned CVEs (CVEs with no remaining workload references)
            val orphanedCveIds = Cves.selectAll()
                .where { 
                    Cves.id notInSubQuery(
                        WorkloadVulnerabilities
                            .select(WorkloadVulnerabilities.cveId)
                            .withDistinct()
                    )
                }
                .map { it[Cves.id] }
            
            if (orphanedCveIds.isNotEmpty()) {
                Cves.deleteWhere { id inList orphanedCveIds }
                logger.debug("Cleaned up ${orphanedCveIds.size} orphaned CVEs for team $teamSlug")
            }
            
            deletedCount
        }
    } catch (e: kotlinx.coroutines.CancellationException) {
        logger.debug("Data cleanup cancelled for team $teamSlug (likely instance shutdown)")
        throw e
    } catch (e: Exception) {
        logger.error("Database error deleting old data for team $teamSlug: ${e.message}")
        throw e
    }

    override suspend fun getTeamVulnerabilityCounts(): List<TeamVulnerabilityCount> = try {
        dbQuery {
            (WorkloadVulnerabilities innerJoin Cves)
                .select(
                    WorkloadVulnerabilities.teamSlug,
                    WorkloadVulnerabilities.id.count(),
                    Cves.severity
                )
                .where {
                    (WorkloadVulnerabilities.resolvedAt.isNull()) and
                    (WorkloadVulnerabilities.suppressed eq false)
                }
                .groupBy(WorkloadVulnerabilities.teamSlug, Cves.severity)
                .associate { row ->
                    val team = row[WorkloadVulnerabilities.teamSlug]
                    val severity = row[Cves.severity]?.uppercase() ?: "UNKNOWN"
                    val count = row[WorkloadVulnerabilities.id.count()].toInt()
                    Pair(team, severity) to count
                }
                .entries
                .groupBy({ it.key.first }) { Pair(it.key.second, it.value) }
                .map { (teamSlug, severityCounts) ->
                    val countsMap = severityCounts.toMap()
                    TeamVulnerabilityCount(
                        teamSlug = teamSlug,
                        totalCount = severityCounts.sumOf { it.second },
                        criticalCount = countsMap["CRITICAL"] ?: 0,
                        highCount = countsMap["HIGH"] ?: 0,
                        mediumCount = countsMap["MEDIUM"] ?: 0,
                        lowCount = countsMap["LOW"] ?: 0,
                        unknownCount = countsMap["UNKNOWN"] ?: 0
                    )
                }
                .sortedByDescending { it.totalCount }
        }
    } catch (e: Exception) {
        logger.error("Database error fetching team vulnerability counts: ${e.message}")
        throw e
    }

    override suspend fun getTeamSlaSummaries(): List<TeamSlaSummary> = try {
        dbQuery {
            val now = Instant.now()
            
            val vulnerabilities = (WorkloadVulnerabilities innerJoin Cves)
                .selectAll()
                .where {
                    (WorkloadVulnerabilities.resolvedAt.isNull()) and
                    (WorkloadVulnerabilities.suppressed eq false)
                }
                .map { row ->
                    val teamSlug = row[WorkloadVulnerabilities.teamSlug]
                    val appRepository = row[WorkloadVulnerabilities.appRepository]
                    val severity = row[Cves.severity]?.uppercase() ?: "UNKNOWN"
                    val discoveredAt = row[WorkloadVulnerabilities.discoveredAt]
                    
                    val isCritical = severity == "CRITICAL"
                    val deadline = if (isCritical) {
                        discoveredAt.plusMillis(34 * 60 * 60 * 1000)
                    } else {
                        discoveredAt.plusMillis(30L * 24 * 60 * 60 * 1000)
                    }
                    val isOverdue = now.isAfter(deadline)
                    val daysOverdue = if (isOverdue) {
                        java.time.Duration.between(deadline, now).toDays()
                    } else 0L
                    
                    VulnSlaInfo(
                        teamSlug = teamSlug,
                        cveId = "",
                        appName = "",
                        appRepository = appRepository,
                        severity = severity,
                        discoveredAt = discoveredAt,
                        isCritical = isCritical,
                        isOverdue = isOverdue,
                        daysOverdue = daysOverdue
                    )
                }
            
            val teamGroups = vulnerabilities.groupBy { it.teamSlug }
            
            teamGroups.map { (teamSlug, vulns) ->
                val criticalOverdue = vulns.count { it.isCritical && it.isOverdue }
                val criticalWithinSla = vulns.count { it.isCritical && !it.isOverdue }
                val nonCriticalOverdue = vulns.count { !it.isCritical && it.isOverdue }
                val nonCriticalWithinSla = vulns.count { !it.isCritical && !it.isOverdue }
                
                val overdueVulns = vulns.filter { it.isOverdue }
                val repositoriesOutOfSla = overdueVulns.mapNotNull { it.appRepository }.distinct().count()
                val maxDaysOverdue = overdueVulns.maxOfOrNull { it.daysOverdue } ?: 0L
                
                TeamSlaSummary(
                    teamSlug = teamSlug,
                    totalVulnerabilities = vulns.size,
                    criticalOverdue = criticalOverdue,
                    criticalWithinSla = criticalWithinSla,
                    nonCriticalOverdue = nonCriticalOverdue,
                    nonCriticalWithinSla = nonCriticalWithinSla,
                    repositoriesOutOfSla = repositoriesOutOfSla,
                    maxDaysOverdue = maxDaysOverdue
                )
            }.sortedByDescending { it.criticalOverdue + it.nonCriticalOverdue }
        }
    } catch (e: Exception) {
        logger.error("Database error fetching team SLA summaries: ${e.message}")
        throw e
    }

    override suspend fun getTeamSlaDetails(teamSlugs: List<String>): List<TeamSlaDetails> = try {
        dbQuery {
            val now = Instant.now()
            
            val vulnerabilities = (WorkloadVulnerabilities innerJoin Cves)
                .selectAll()
                .where {
                    (WorkloadVulnerabilities.resolvedAt.isNull()) and
                    (WorkloadVulnerabilities.suppressed eq false) and
                    (WorkloadVulnerabilities.teamSlug inList teamSlugs)
                }
                .map { row ->
                    val cveId = row[WorkloadVulnerabilities.cveId]
                    val teamSlug = row[WorkloadVulnerabilities.teamSlug]
                    val appName = row[WorkloadVulnerabilities.appName]
                    val appRepository = row[WorkloadVulnerabilities.appRepository]
                    val severity = row[Cves.severity]?.uppercase() ?: "UNKNOWN"
                    val discoveredAt = row[WorkloadVulnerabilities.discoveredAt]
                    
                    val isCritical = severity == "CRITICAL"
                    val deadline = if (isCritical) {
                        discoveredAt.plusMillis(34 * 60 * 60 * 1000) // 1 day 10 hours
                    } else {
                        discoveredAt.plusMillis(30L * 24 * 60 * 60 * 1000) // 30 days
                    }
                    val isOverdue = now.isAfter(deadline)
                    val daysOverdue = if (isOverdue) {
                        java.time.Duration.between(deadline, now).toDays()
                    } else 0L
                    
                    VulnSlaInfo(
                        teamSlug = teamSlug,
                        cveId = cveId,
                        appName = appName,
                        appRepository = appRepository,
                        severity = severity,
                        discoveredAt = discoveredAt,
                        isCritical = isCritical,
                        isOverdue = isOverdue,
                        daysOverdue = daysOverdue
                    )
                }
            
            val teamGroups = vulnerabilities.groupBy { it.teamSlug }
            
            teamGroups.map { (teamSlug, vulns) ->
                val criticalOverdue = vulns.count { it.isCritical && it.isOverdue }
                val criticalWithinSla = vulns.count { it.isCritical && !it.isOverdue }
                val nonCriticalOverdue = vulns.count { !it.isCritical && it.isOverdue }
                val nonCriticalWithinSla = vulns.count { !it.isCritical && !it.isOverdue }
                
                val overdueVulns = vulns.filter { it.isOverdue }
                val repositoriesOutOfSla = overdueVulns.mapNotNull { it.appRepository }.distinct().count()
                val maxDaysOverdue = overdueVulns.maxOfOrNull { it.daysOverdue } ?: 0L
                
                val criticalOverdueItems = vulns
                    .filter { it.isCritical && it.isOverdue }
                    .map { 
                        SlaOverdueItem(
                            cveId = it.cveId,
                            applicationName = it.appName,
                            severity = it.severity,
                            discoveredAt = it.discoveredAt,
                            daysOverdue = it.daysOverdue
                        )
                    }
                
                val nonCriticalOverdueItems = vulns
                    .filter { !it.isCritical && it.isOverdue }
                    .map { 
                        SlaOverdueItem(
                            cveId = it.cveId,
                            applicationName = it.appName,
                            severity = it.severity,
                            discoveredAt = it.discoveredAt,
                            daysOverdue = it.daysOverdue
                        )
                    }
                
                TeamSlaDetails(
                    teamSlug = teamSlug,
                    totalVulnerabilities = vulns.size,
                    criticalOverdue = criticalOverdue,
                    criticalWithinSla = criticalWithinSla,
                    nonCriticalOverdue = nonCriticalOverdue,
                    nonCriticalWithinSla = nonCriticalWithinSla,
                    repositoriesOutOfSla = repositoriesOutOfSla,
                    maxDaysOverdue = maxDaysOverdue,
                    criticalOverdueItems = criticalOverdueItems,
                    nonCriticalOverdueItems = nonCriticalOverdueItems
                )
            }.sortedByDescending { it.criticalOverdue + it.nonCriticalOverdue }
        }
    } catch (e: Exception) {
        logger.error("Database error fetching team SLA details: ${e.message}")
        throw e
    }

    override suspend fun updateTeamSyncMetadata(teamSlug: String, syncTime: Instant): Unit = dbQuery {
        val now = Instant.now()
        TeamSyncMetadata.upsert(TeamSyncMetadata.teamSlug) {
            it[TeamSyncMetadata.teamSlug] = teamSlug
            it[lastSyncedAt] = syncTime
            it[createdAt] = now
            it[updatedAt] = now
        }
        Unit
    }
    
    override suspend fun getTeamLastSyncTime(teamSlug: String): Instant? = dbQuery {
        TeamSyncMetadata.selectAll()
            .where { TeamSyncMetadata.teamSlug eq teamSlug }
            .singleOrNull()
            ?.get(TeamSyncMetadata.lastSyncedAt)
    }
    
    override suspend fun getTeamsNeedingSync(teamSlugs: List<String>, olderThan: Instant): List<String> = dbQuery {
        val syncedTeams = TeamSyncMetadata.selectAll()
            .where {
                (TeamSyncMetadata.teamSlug inList teamSlugs) and
                (TeamSyncMetadata.lastSyncedAt greaterEq olderThan)
            }
            .map { it[TeamSyncMetadata.teamSlug] }
            .toSet()
        
        teamSlugs.filterNot { it in syncedTeams }
    }
    
    private data class VulnSlaInfo(
        val teamSlug: String,
        val cveId: String,
        val appName: String,
        val appRepository: String?,
        val severity: String,
        val discoveredAt: Instant,
        val isCritical: Boolean,
        val isOverdue: Boolean,
        val daysOverdue: Long
    )

    private fun ResultRow.toVulnerabilitySearchResult() = VulnerabilitySearchResult(
        cveId = this[WorkloadVulnerabilities.cveId],
        teamSlug = this[WorkloadVulnerabilities.teamSlug],
        applicationName = this[WorkloadVulnerabilities.appName],
        applicationNaisId = this[WorkloadVulnerabilities.appNaisId],
        workloadType = this[WorkloadVulnerabilities.appWorkloadType],
        environment = this[WorkloadVulnerabilities.appEnvironment],
        repository = this[WorkloadVulnerabilities.appRepository],
        imageTag = this[WorkloadVulnerabilities.appImageTag],
        ingressTypes = this[WorkloadVulnerabilities.appIngressTypes] ?: emptyList(),
        packageName = this[WorkloadVulnerabilities.packageName],
        severity = this[Cves.severity],
        description = this[Cves.description],
        vulnerabilityDetailsLink = this[Cves.vulnerabilityDetailsLink],
        hasExternalIngress = this[WorkloadVulnerabilities.appHasExternalIngress],
        suppressed = this[WorkloadVulnerabilities.suppressed],
        discoveredAt = this[WorkloadVulnerabilities.discoveredAt],
        lastSeenAt = this[WorkloadVulnerabilities.lastSeenAt]
    )
}
