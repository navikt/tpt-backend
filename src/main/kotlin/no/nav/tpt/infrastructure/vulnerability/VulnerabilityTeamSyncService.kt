package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.NaisApiService
import org.slf4j.LoggerFactory
import java.time.Instant

class VulnerabilityTeamSyncService(
    private val naisApiService: NaisApiService,
    private val vulnerabilityRepository: VulnerabilityRepository
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityTeamSyncService::class.java)

    data class TeamSyncResult(
        val teamSlug: String,
        val processed: Int,
        val inserted: Int,
        val skipped: Int,
        val skippedReasons: Map<String, Int> = emptyMap()
    )

    suspend fun syncTeams(teamSlugs: List<String>, teamSlackChannels: Map<String, String?> = emptyMap()): List<TeamSyncResult> {
        val syncTime = Instant.now()
        return teamSlugs.map { teamSlug ->
            syncTeam(teamSlug, teamSlackChannels[teamSlug], syncTime)
        }
    }

    private suspend fun syncTeam(teamSlug: String, teamSlackChannel: String?, syncTime: Instant): TeamSyncResult {
        var processed = 0
        var inserted = 0
        var skipped = 0
        val skippedReasons = mutableMapOf<String, Int>()

        try {
            val vulnerabilityData = naisApiService.getVulnerabilitiesForTeam(teamSlug)

            vulnerabilityData.teams.forEach { teamVulnData ->
                teamVulnData.workloads.forEach { workload ->
                    workload.vulnerabilities.forEach { vuln ->
                        processed++

                        val trackingData = VulnerabilityTrackingData(
                            id = null,
                            teamSlug = teamSlug,
                            teamSlackChannel = teamSlackChannel,
                            appNaisId = workload.id,
                            appName = workload.name,
                            appWorkloadType = workload.workloadType,
                            appEnvironment = workload.environment,
                            appRepository = workload.repository,
                            appImageName = extractImageName(workload.imageTag),
                            appImageTag = workload.imageTag,
                            appHasExternalIngress = workload.ingressTypes.any { it.equals("external", ignoreCase = true) },
                            appIngressTypes = workload.ingressTypes,
                            cveId = vuln.identifier,
                            packageName = vuln.packageName,
                            severity = vuln.severity,
                            description = vuln.description,
                            vulnerabilityDetailsLink = vuln.vulnerabilityDetailsLink,
                            suppressed = vuln.suppressed,
                            discoveredAt = syncTime,
                            lastSeenAt = syncTime,
                            resolvedAt = null,
                            syncTimestamp = syncTime
                        )

                        val validationResult = validateVulnerabilityData(trackingData)
                        if (validationResult.isNotEmpty()) {
                            skipped++
                            validationResult.forEach { reason ->
                                skippedReasons[reason] = (skippedReasons[reason] ?: 0) + 1
                            }
                            logger.warn("Skipping vulnerability for team $teamSlug, app ${workload.name}, CVE ${vuln.identifier}: ${validationResult.joinToString()}")
                            return@forEach
                        }

                        try {
                            vulnerabilityRepository.upsertVulnerability(trackingData)
                            inserted++
                            logger.debug("Upserted vulnerability ${vuln.identifier} for team $teamSlug, app ${workload.name}")
                        } catch (e: Exception) {
                            skipped++
                            val reason = categorizeError(e)
                            skippedReasons[reason] = (skippedReasons[reason] ?: 0) + 1
                            logger.warn("Failed to upsert vulnerability ${vuln.identifier} for team $teamSlug, app ${workload.name}: ${e.message}")
                        }
                    }
                }
            }
        } catch (e: Exception) {
            logger.error("Failed to sync team $teamSlug: ${e.message}", e)
            throw e
        }

        return TeamSyncResult(teamSlug, processed, inserted, skipped, skippedReasons)
    }

    private fun validateVulnerabilityData(data: VulnerabilityTrackingData): List<String> {
        val errors = mutableListOf<String>()

        if (data.cveId.length > 50) {
            errors.add("cve_id_too_long")
        }
        if (data.teamSlug.length > 100) {
            errors.add("team_slug_too_long")
        }
        if (data.appName.length > 255) {
            errors.add("app_name_too_long")
        }
        if (data.packageName != null && data.packageName.length > 255) {
            errors.add("package_name_too_long")
        }
        if (data.appImageName != null && data.appImageName.length > 500) {
            errors.add("image_name_too_long")
        }
        if (data.appImageTag != null && data.appImageTag.length > 500) {
            errors.add("image_tag_too_long")
        }
        if (data.severity != null && data.severity.length > 20) {
            errors.add("severity_too_long")
        }

        return errors
    }

    private fun categorizeError(e: Exception): String {
        val message = e.message ?: ""
        return when {
            message.contains("constraint", ignoreCase = true) -> "constraint_violation"
            message.contains("duplicate", ignoreCase = true) -> "duplicate_key"
            message.contains("foreign key", ignoreCase = true) -> "foreign_key_violation"
            message.contains("data too long", ignoreCase = true) -> "data_too_long"
            else -> "database_error"
        }
    }

    private fun extractImageName(imageTag: String?): String? {
        if (imageTag == null) return null
        return imageTag.substringBeforeLast(':')
    }
}
