package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.vulnerability.VulnerabilityRepository
import no.nav.tpt.domain.vulnerability.VulnerabilityTrackingData
import no.nav.tpt.infrastructure.nais.NaisApiService
import org.slf4j.LoggerFactory
import java.time.Instant

class VulnerabilityTeamSyncService(
    private val naisApiService: NaisApiService,
    private val vulnerabilityRepository: VulnerabilityRepository
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityTeamSyncService::class.java)

    data class TeamSyncResult(
        val teamSlug: String,
        val processed: Int,
        val inserted: Int,
        val skipped: Int,
        val skippedReasons: Map<String, Int> = emptyMap()
    )

    suspend fun syncTeams(teamSlugs: List<String>, teamSlackChannels: Map<String, String?> = emptyMap()): List<TeamSyncResult> {
        val syncTime = Instant.now()
        return teamSlugs.map { teamSlug ->
            syncTeam(teamSlug, teamSlackChannels[teamSlug], syncTime)
        }
    }

    private suspend fun syncTeam(teamSlug: String, teamSlackChannel: String?, syncTime: Instant): TeamSyncResult {
        var processed = 0
        var skipped = 0
        val skippedReasons = mutableMapOf<String, Int>()
        val validVulnerabilities = mutableListOf<VulnerabilityTrackingData>()

        try {
            val vulnerabilityData = naisApiService.getVulnerabilitiesForTeam(teamSlug)

            vulnerabilityData.teams.forEach { teamVulnData ->
                teamVulnData.workloads.forEach { workload ->
                    workload.vulnerabilities.forEach { vuln ->
                        processed++

                        val trackingData = VulnerabilityTrackingData(
                            id = null,
                            teamSlug = teamSlug,
                            teamSlackChannel = teamSlackChannel,
                            appNaisId = workload.id,
                            appName = workload.name,
                            appWorkloadType = workload.workloadType,
                            appEnvironment = workload.environment,
                            appRepository = workload.repository,
                            appImageName = extractImageName(workload.imageTag),
                            appImageTag = workload.imageTag,
                            appHasExternalIngress = workload.ingressTypes.any { it.equals("external", ignoreCase = true) },
                            appIngressTypes = workload.ingressTypes,
                            cveId = vuln.identifier,
                            packageName = vuln.packageName,
                            severity = vuln.severity,
                            description = vuln.description,
                            vulnerabilityDetailsLink = vuln.vulnerabilityDetailsLink,
                            suppressed = vuln.suppressed,
                            discoveredAt = syncTime,
                            lastSeenAt = syncTime,
                            resolvedAt = null,
                            syncTimestamp = syncTime
                        )

                        val validationResult = validateVulnerabilityData(trackingData)
                        if (validationResult.isNotEmpty()) {
                            skipped++
                            validationResult.forEach { reason ->
                                skippedReasons[reason] = (skippedReasons[reason] ?: 0) + 1
                            }
                            logger.warn("Skipping vulnerability for team $teamSlug, app ${workload.name}, CVE ${vuln.identifier}: ${validationResult.joinToString()}")
                            return@forEach
                        }

                        validVulnerabilities.add(trackingData)
                    }
                }
            }

            val inserted = vulnerabilityRepository.batchUpsertVulnerabilities(validVulnerabilities)
            vulnerabilityRepository.updateTeamSyncMetadata(teamSlug, syncTime)
            logger.debug("Synced $inserted vulnerabilities for team $teamSlug")
        } catch (e: kotlinx.coroutines.CancellationException) {
            logger.debug("Team sync cancelled for $teamSlug (instance shutting down)")
            throw e
        } catch (e: Exception) {
            logger.error("Failed to sync team $teamSlug: ${e.message}", e)
            throw e
        }

        return TeamSyncResult(teamSlug, processed, validVulnerabilities.size, skipped, skippedReasons)
    }

    private fun validateVulnerabilityData(data: VulnerabilityTrackingData): List<String> {
        val errors = mutableListOf<String>()

        if (data.cveId.length > 50) {
            errors.add("cve_id_too_long")
        }
        if (data.teamSlug.length > 100) {
            errors.add("team_slug_too_long")
        }
        if (data.appName.length > 255) {
            errors.add("app_name_too_long")
        }
        if (data.packageName != null && data.packageName.length > 255) {
            errors.add("package_name_too_long")
        }
        if (data.appImageName != null && data.appImageName.length > 500) {
            errors.add("image_name_too_long")
        }
        if (data.appImageTag != null && data.appImageTag.length > 500) {
            errors.add("image_tag_too_long")
        }
        if (data.severity != null && data.severity.length > 20) {
            errors.add("severity_too_long")
        }

        return errors
    }

    private fun extractImageName(imageTag: String?): String? {
        if (imageTag == null) return null
        return imageTag.substringBeforeLast(':')
    }
}
