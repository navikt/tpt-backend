package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.vulnerability.*
import java.time.Duration
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.DayOfWeek

class VulnerabilitySearchService(
    private val vulnerabilityRepository: VulnerabilityRepository
) {

    suspend fun searchVulnerabilities(request: VulnerabilitySearchRequest): VulnerabilitySearchResponse {
        val offset = (request.page - 1) * request.pageSize

        val (results, totalCount) = vulnerabilityRepository.searchVulnerabilities(
            cveId = request.cveId,
            teamSlug = request.teamSlug,
            severities = request.severity,
            hasExternalIngress = request.hasExternalIngress,
            suppressed = request.suppressed,
            limit = request.pageSize,
            offset = offset
        )

        val items = results.map { it.toSearchItem() }

        return VulnerabilitySearchResponse(
            items = items,
            totalCount = totalCount,
            page = request.page,
            pageSize = request.pageSize
        )
    }

    suspend fun getOverdueSlaReport(teamSlugs: List<String>?): SlaOverdueResponse {
        val allVulns = if (teamSlugs.isNullOrEmpty()) {
            return SlaOverdueResponse(
                teams = emptyList(),
                totalOverdue = 0,
                generatedAt = Instant.now().toString()
            )
        } else {
            vulnerabilityRepository.getActiveVulnerabilitiesForTeams(teamSlugs)
        }
        
        val now = Instant.now()
        
        data class VulnWithSla(
            val vuln: VulnerabilitySearchResult,
            val isOverdue: Boolean,
            val isCritical: Boolean,
            val daysOverdue: Long,
            val workdaysOverdue: Int?
        )
        
        val vulnsWithSla = allVulns.map { vuln ->
            val isCritical = vuln.severity?.uppercase() == "CRITICAL"
            val isOverdue: Boolean
            val daysOverdue: Long
            val workdaysOverdue: Int?
            
            if (isCritical) {
                val deadline = addWorkdays(vuln.discoveredAt, 1)
                isOverdue = now.isAfter(deadline)
                daysOverdue = Duration.between(vuln.discoveredAt, now).toDays()
                workdaysOverdue = if (isOverdue) calculateWorkdaysSince(deadline, now) else null
            } else {
                val deadline = vuln.discoveredAt.plus(30, java.time.temporal.ChronoUnit.DAYS)
                isOverdue = now.isAfter(deadline)
                daysOverdue = Duration.between(deadline, now).toDays()
                workdaysOverdue = null
            }
            
            VulnWithSla(vuln, isOverdue, isCritical, daysOverdue, workdaysOverdue)
        }

        val teamGroups = vulnsWithSla.groupBy { it.vuln.teamSlug }

        val teamStatuses = teamGroups.map { (teamSlug, vulns) ->
            val criticals = vulns.filter { it.isCritical }
            val nonCriticals = vulns.filter { !it.isCritical }
            
            val criticalOverdue = criticals.count { it.isOverdue }
            val nonCriticalOverdue = nonCriticals.count { it.isOverdue }
            val criticalWithinSla = criticals.count { !it.isOverdue }
            val nonCriticalWithinSla = nonCriticals.count { !it.isOverdue }
            
            val criticalOverdueItems = criticals.filter { it.isOverdue }.map {
                OverdueItem(
                    cveId = it.vuln.cveId,
                    applicationName = it.vuln.applicationName,
                    severity = it.vuln.severity,
                    daysOverdue = it.daysOverdue,
                    workdaysOverdue = it.workdaysOverdue
                )
            }
            
            val nonCriticalOverdueItems = nonCriticals.filter { it.isOverdue }.map {
                OverdueItem(
                    cveId = it.vuln.cveId,
                    applicationName = it.vuln.applicationName,
                    severity = it.vuln.severity,
                    daysOverdue = it.daysOverdue,
                    workdaysOverdue = null
                )
            }
            
            // Calculate repository-level statistics
            val overdueVulns = vulns.filter { it.isOverdue }
            val repositoriesWithOverdueVulns = overdueVulns
                .mapNotNull { it.vuln.repository }
                .distinct()
                .count()
            
            val maxDaysOverdue = overdueVulns.maxOfOrNull { it.daysOverdue } ?: 0L

            TeamSlaStatus(
                teamSlug = teamSlug,
                criticalOverdue = criticalOverdue,
                nonCriticalOverdue = nonCriticalOverdue,
                criticalWithinSla = criticalWithinSla,
                nonCriticalWithinSla = nonCriticalWithinSla,
                totalVulnerabilities = vulns.size,
                repositoriesOutOfSla = repositoriesWithOverdueVulns,
                maxDaysOverdue = maxDaysOverdue,
                criticalOverdueItems = if (criticalOverdueItems.isNotEmpty()) criticalOverdueItems else null,
                nonCriticalOverdueItems = if (nonCriticalOverdueItems.isNotEmpty()) nonCriticalOverdueItems else null
            )
        }.sortedByDescending { it.criticalOverdue + it.nonCriticalOverdue }

        val totalOverdue = vulnsWithSla.count { it.isOverdue }

        return SlaOverdueResponse(
            teams = teamStatuses,
            totalOverdue = totalOverdue,
            generatedAt = now.toString()
        )
    }

    private fun VulnerabilitySearchResult.toSearchItem(): VulnerabilitySearchItem {
        val daysVulnerable = Duration.between(discoveredAt, Instant.now()).toDays()
        val slaStatus = calculateSlaStatus(severity, discoveredAt)

        return VulnerabilitySearchItem(
            cveId = cveId,
            teamSlug = teamSlug,
            applicationName = applicationName,
            applicationId = applicationNaisId,
            workloadType = workloadType,
            environment = environment,
            packageName = packageName,
            severity = severity,
            hasExternalIngress = hasExternalIngress,
            suppressed = suppressed,
            discoveredAt = discoveredAt.toString(),
            lastSeenAt = lastSeenAt.toString(),
            daysVulnerable = daysVulnerable,
            slaStatus = slaStatus
        )
    }

    private fun calculateSlaStatus(severity: String?, discoveredAt: Instant): String {
        val now = Instant.now()
        
        return when (severity?.uppercase()) {
            "CRITICAL" -> {
                val deadline = addWorkdays(discoveredAt, 1)
                when {
                    now.isAfter(deadline) -> "OVERDUE"
                    else -> "WITHIN_SLA"
                }
            }
            else -> {
                val deadline = discoveredAt.plus(30, java.time.temporal.ChronoUnit.DAYS)
                val daysUntilDeadline = Duration.between(now, deadline).toDays()
                when {
                    daysUntilDeadline < 0 -> "OVERDUE"
                    daysUntilDeadline <= 7 -> "DUE_SOON"
                    else -> "WITHIN_SLA"
                }
            }
        }
    }

    private fun addWorkdays(start: Instant, workdays: Int): Instant {
        val zoneId = ZoneId.of("Europe/Oslo")
        var current = LocalDateTime.ofInstant(start, zoneId)
        var remaining = workdays

        while (remaining > 0) {
            current = current.plusDays(1)
            if (current.dayOfWeek != DayOfWeek.SATURDAY && current.dayOfWeek != DayOfWeek.SUNDAY) {
                remaining--
            }
        }

        return current.atZone(zoneId).toInstant()
    }

    private fun calculateWorkdaysSince(deadline: Instant, now: Instant): Int {
        val zoneId = ZoneId.of("Europe/Oslo")
        var current = LocalDateTime.ofInstant(deadline, zoneId)
        val end = LocalDateTime.ofInstant(now, zoneId)
        var workdays = 0

        while (current.isBefore(end)) {
            current = current.plusDays(1)
            if (current.dayOfWeek != DayOfWeek.SATURDAY && current.dayOfWeek != DayOfWeek.SUNDAY) {
                workdays++
            }
        }

        return workdays
    }
}
