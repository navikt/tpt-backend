package no.nav.tpt.infrastructure.vulnerability

import no.nav.tpt.domain.vulnerability.*
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.DayOfWeek

class VulnerabilitySearchService(
    private val vulnerabilityRepository: VulnerabilityRepository
) {

    suspend fun getOverdueSlaReport(teamSlugs: List<String>?): SlaOverdueResponse {
        if (teamSlugs.isNullOrEmpty()) {
            return SlaOverdueResponse(
                teams = emptyList(),
                totalOverdue = 0,
                generatedAt = Instant.now().toString()
            )
        }
        
        val now = Instant.now()
        val teamDetails = vulnerabilityRepository.getTeamSlaDetails(teamSlugs)
        
        val teamStatuses = teamDetails.map { details ->
            val criticalOverdueItems = details.criticalOverdueItems.map { item ->
                val deadline = addWorkdays(item.discoveredAt, 1)
                val workdaysOverdue = if (now.isAfter(deadline)) {
                    calculateWorkdaysSince(deadline, now)
                } else null
                
                OverdueItem(
                    cveId = item.cveId,
                    applicationName = item.applicationName,
                    severity = item.severity,
                    daysOverdue = item.daysOverdue,
                    workdaysOverdue = workdaysOverdue
                )
            }
            
            val nonCriticalOverdueItems = details.nonCriticalOverdueItems.map { item ->
                OverdueItem(
                    cveId = item.cveId,
                    applicationName = item.applicationName,
                    severity = item.severity,
                    daysOverdue = item.daysOverdue,
                    workdaysOverdue = null
                )
            }
            
            TeamSlaStatus(
                teamSlug = details.teamSlug,
                criticalOverdue = details.criticalOverdue,
                nonCriticalOverdue = details.nonCriticalOverdue,
                criticalWithinSla = details.criticalWithinSla,
                nonCriticalWithinSla = details.nonCriticalWithinSla,
                totalVulnerabilities = details.totalVulnerabilities,
                repositoriesOutOfSla = details.repositoriesOutOfSla,
                maxDaysOverdue = details.maxDaysOverdue,
                criticalOverdueItems = if (criticalOverdueItems.isNotEmpty()) criticalOverdueItems else null,
                nonCriticalOverdueItems = if (nonCriticalOverdueItems.isNotEmpty()) nonCriticalOverdueItems else null
            )
        }
        
        val totalOverdue = teamStatuses.sumOf { it.criticalOverdue + it.nonCriticalOverdue }

        return SlaOverdueResponse(
            teams = teamStatuses,
            totalOverdue = totalOverdue,
            generatedAt = now.toString()
        )
    }

    private fun addWorkdays(start: Instant, workdays: Int): Instant {
        val zoneId = ZoneId.of("Europe/Oslo")
        var current = LocalDateTime.ofInstant(start, zoneId)
        var remaining = workdays

        while (remaining > 0) {
            current = current.plusDays(1)
            if (current.dayOfWeek != DayOfWeek.SATURDAY && current.dayOfWeek != DayOfWeek.SUNDAY) {
                remaining--
            }
        }

        return current.atZone(zoneId).toInstant()
    }

    private fun calculateWorkdaysSince(deadline: Instant, now: Instant): Int {
        val zoneId = ZoneId.of("Europe/Oslo")
        var current = LocalDateTime.ofInstant(deadline, zoneId)
        val end = LocalDateTime.ofInstant(now, zoneId)
        var workdays = 0

        while (current.isBefore(end)) {
            current = current.plusDays(1)
            if (current.dayOfWeek != DayOfWeek.SATURDAY && current.dayOfWeek != DayOfWeek.SUNDAY) {
                workdays++
            }
        }

        return workdays
    }
}
