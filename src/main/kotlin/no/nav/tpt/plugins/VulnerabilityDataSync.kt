package no.nav.tpt.plugins

import io.ktor.server.application.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.minutes

fun Application.configureVulnerabilityDataSync() {
    val logger = LoggerFactory.getLogger("VulnerabilityDataSync")
    val syncJob = dependencies.vulnerabilityDataSyncJob
    val leaderElection = dependencies.leaderElection

    // Start leader election checks
    leaderElection.startLeaderElectionChecks(this)

    val syncTimes = listOf(LocalTime.of(6, 0), LocalTime.of(18, 0))
    val timezone = ZoneId.of("Europe/Oslo")

    logger.info("Vulnerability data sync scheduler configured: sync times=${syncTimes.joinToString(", ")} (${timezone})")

    launch {
        while (true) {
            val delayUntilNext = calculateDelayUntilNextSync(syncTimes, timezone)
            val nextSyncTime = LocalDateTime.now(timezone).plus(delayUntilNext.inWholeMilliseconds, ChronoUnit.MILLIS)
            logger.info("Next vulnerability data sync scheduled at $nextSyncTime")
            
            delay(delayUntilNext)

            // Retry logic to handle leadership transitions during sync window
            var syncAttempts = 0
            val maxAttempts = 5
            var syncCompleted = false
            
            while (syncAttempts < maxAttempts && !syncCompleted) {
                try {
                    val isLeader = leaderElection.isLeader()
                    if (isLeader) {
                        logger.info("This pod is the leader - starting scheduled vulnerability data sync (attempt ${syncAttempts + 1})")
                        syncJob.syncAllTeams()
                        logger.info("Scheduled vulnerability data sync completed")
                        syncCompleted = true
                    } else {
                        syncAttempts++
                        if (syncAttempts < maxAttempts) {
                            logger.debug("This pod is not the leader - retrying in 2 minutes (attempt $syncAttempts/$maxAttempts)")
                            delay(2.minutes)
                        } else {
                            logger.debug("This pod is not the leader after $maxAttempts attempts - skipping sync")
                        }
                    }
                } catch (e: Exception) {
                    logger.error("Scheduled vulnerability data sync failed (attempt ${syncAttempts + 1})", e)
                    syncCompleted = true // Don't retry on errors, wait for next scheduled time
                }
            }
        }
    }

    logger.info("Vulnerability data sync scheduler started with Kubernetes leader election")
}

private fun calculateDelayUntilNextSync(syncTimes: List<LocalTime>, timezone: ZoneId): kotlin.time.Duration {
    val now = LocalDateTime.now(timezone)
    val today = now.toLocalDate()
    
    val nextSyncDateTime = syncTimes
        .map { today.atTime(it) }
        .filter { it.isAfter(now) }
        .minOrNull()
        ?: today.plusDays(1).atTime(syncTimes.first())
    
    val millisUntilNext = ChronoUnit.MILLIS.between(now, nextSyncDateTime)
    return millisUntilNext.milliseconds
}
