package no.nav.tpt.plugins

import io.ktor.server.application.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.slf4j.LoggerFactory
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.minutes

fun Application.configureVulnerabilityDataSync() {
    val logger = LoggerFactory.getLogger("VulnerabilityDataSync")
    val syncJob = dependencies.vulnerabilityDataSyncJob
    val leaderElection = dependencies.leaderElection

    // Start leader election checks
    leaderElection.startLeaderElectionChecks(this)

    val syncIntervalHours = environment.config.propertyOrNull("sync.intervalHours")?.getString()?.toLongOrNull() ?: 6L
    val initialDelayMinutes = environment.config.propertyOrNull("sync.initialDelayMinutes")?.getString()?.toLongOrNull() ?: 5L

    logger.info("Vulnerability data sync scheduler configured: interval=${syncIntervalHours}h, initial delay=${initialDelayMinutes}m")

    launch {
        logger.info("Waiting ${initialDelayMinutes} minutes before first sync to allow deployment to stabilize")
        delay(initialDelayMinutes.minutes)

        while (true) {
            try {
                val isLeader = leaderElection.isLeader()
                if (isLeader) {
                    logger.info("This pod is the leader - starting scheduled vulnerability data sync")
                    syncJob.syncAllTeams()
                    logger.info("Scheduled vulnerability data sync completed")
                } else {
                    logger.info("This pod is not the leader - skipping sync. Next check in ${syncIntervalHours} hours")
                }
            } catch (e: Exception) {
                logger.error("Scheduled vulnerability data sync failed", e)
            }

            delay(syncIntervalHours.hours)
        }
    }

    logger.info("Vulnerability data sync scheduler started with Kubernetes leader election")
}
